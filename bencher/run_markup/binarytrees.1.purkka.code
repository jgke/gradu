<span class="slc">// The Computer Language Benchmarks Game</span>
<span class="slc">// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">//</span>
<span class="slc">// Contributed by Jeremy Zerfas</span>
<span class="slc">// Based on the C++ program from Jon Harrop, Alex Mizrahi, and Bruno Coutinho.</span>

import <span class="str">&quot;stdint.h&quot;</span>
import <span class="str">&quot;stdlib.h&quot;</span>
import <span class="str">&quot;stdio.h&quot;</span>
import <span class="str">&quot;apr_pools.h&quot;</span>

<span class="kwb">struct</span> TreeNode {
    left: &amp;?TreeNode,
    right: &amp;?TreeNode
};


<span class="slc">// Create a binary tree of depth treeDepth in memoryPool and return a pointer</span>
<span class="slc">// to the created binary tree.</span>
fun <span class="kwd">createTree</span>(treeDepth: i64, memoryPool: &amp;apr_pool_t) {
    let rootNode = &#64;<span class="str">&quot;apr_pcalloc(memoryPool, sizeof(TreeNode))&quot;</span> as &amp;TreeNode;

    <span class="slc">// If treeDepth is one or more then recursively call createTree() in order</span>
    <span class="slc">// to create the left and right subtrees.</span>
    <span class="kwa">if</span>(treeDepth &gt; <span class="num">0</span>) {
        (*rootNode).left=<span class="kwd">createTree</span>(treeDepth-<span class="num">1</span>, memoryPool);
        (*rootNode).right=<span class="kwd">createTree</span>(treeDepth-<span class="num">1</span>, memoryPool);
    }

    <span class="kwa">return</span> rootNode;
}


<span class="slc">// Compute and return the checksum for the binary tree that has rootNode as the</span>
<span class="slc">// root node.</span>
fun <span class="kwd">computeTreeChecksum</span>(rootNode: &amp;TreeNode) -&gt; i64 {
    <span class="slc">// If there are subtrees then recursively call computeTreeChecksum() on</span>
    <span class="slc">// them and return 1 plus the checksum of those subtrees.</span>
    <span class="kwa">if</span>((*rootNode).left &amp;&amp; (*rootNode).right) {
        <span class="kwa">return</span> <span class="kwd">computeTreeChecksum</span>((*rootNode).left)+
            <span class="kwd">computeTreeChecksum</span>((*rootNode).right)+<span class="num">1</span>;
    }

    <span class="slc">// If the function gets here then this is a single node tree so just return</span>
    <span class="slc">// 1 as the checksum.</span>
    <span class="kwa">return</span> <span class="num">1</span>;
}


fun <span class="kwd">main</span>(argc: i32, argv) -&gt; i32 {
    <span class="slc">// Set minimumTreeDepth to 4 and maximumTreeDepth to the maximum of what</span>
    <span class="slc">// was specified as the argument to the program and minimumTreeDepth+2.</span>
    let minimumTreeDepth: i64 = <span class="num">4</span>;
    let maximumTreeDepth: i64 = <span class="kwd">atol</span>(argv[<span class="num">1</span>]) &lt; minimumTreeDepth+<span class="num">2</span>
        ? minimumTreeDepth+<span class="num">2</span>
        : <span class="kwd">atol</span>(argv[<span class="num">1</span>]);

    <span class="kwd">apr_initialize</span>();

    <span class="slc">// Create a memoryPool which will be used for storing both the stretchTree</span>
    <span class="slc">// and the longLivedTree.</span>
    let memoryPool: &amp;apr_pool_t;
    &#64;<span class="str">&quot;apr_pool_create_unmanaged(&amp;memoryPool)&quot;</span>;

    <span class="slc">// Create a stretchTree of depth maximumTreeDepth+1, compute its</span>
    <span class="slc">// checksum, and print its statistics. This work could be done in parallel</span>
    <span class="slc">// along with all the other tree processing but APR memory pools aren&apos;t</span>
    <span class="slc">// quite as streamlined as other memory pool implementations so it uses less</span>
    <span class="slc">// resources to do this work by itself and then clear the memoryPool so</span>
    <span class="slc">// that most of the memory that was already allocated for the stretchTree</span>
    <span class="slc">// can be reused for the upcoming longLivedTree work rather than having</span>
    <span class="slc">// APR allocate more memory for memory pools. Unfortunately since the</span>
    <span class="slc">// longLivedTree is about half the size of the stretchTree, this ends up</span>
    <span class="slc">// wasting about half the memory that was being used by the stretchTree.</span>
    <span class="slc">// APR subpools could be used to use that otherwise wasted memory for the</span>
    <span class="slc">// processing of other trees that will be done later but it appears subpools</span>
    <span class="slc">// only work with managed pools (even though APR&apos;s documentation for the</span>
    <span class="slc">// apr_pool_create_unmanaged_ex() function seems to suggest that it possibly</span>
    <span class="slc">// should work for unmanaged pools too) which are noticeably slower than</span>
    <span class="slc">// unmanaged memory pools.</span>
    let stretchTree = <span class="kwd">createTree</span>(maximumTreeDepth+<span class="num">1</span>, memoryPool);
    <span class="kwd">printf</span>(<span class="str">&quot;stretch tree of depth %jd</span><span class="esc">\t</span> <span class="str">check: %jd</span><span class="esc">\n</span><span class="str">&quot;</span>,
            maximumTreeDepth+<span class="num">1</span>,
            <span class="kwd">computeTreeChecksum</span>(stretchTree));
    <span class="kwd">apr_pool_clear</span>(memoryPool);

    <span class="slc">// The longLivedTree will be created in just a little bit simultaneously</span>
    <span class="slc">// (assuming OpenMP was enabled and the program is running on a multi-</span>
    <span class="slc">// processor system) while the rest of the trees are also being processed.</span>
    <span class="slc">// longLivedTree will store the reference to it which will remain valid</span>
    <span class="slc">// until near the end of the program.</span>
    let longLivedTree: &amp;?TreeNode;

    <span class="slc">// These will be used to store checksums for the various trees so the</span>
    <span class="slc">// statistics for the various trees can be output in the correct order</span>
    <span class="slc">// later.</span>
    let longLivedTreeChecksum: i64;
    let treeChecksums: [i64;(maximumTreeDepth-minimumTreeDepth+<span class="num">2</span>)/<span class="num">2</span>];

    pragma <span class="str">&quot;omp parallel&quot;</span>
    {
        <span class="slc">// Have one thread create the longLivedTree of depth</span>
        <span class="slc">// maximumTreeDepth in the memoryPool which was already previously</span>
        <span class="slc">// used for the stretchTree, compute the longLivedTreeChecksum, and</span>
        <span class="slc">// then just leave the longLivedTree alone for a while while the rest</span>
        <span class="slc">// of the binary trees finish processing (which should have</span>
        <span class="slc">// simultaneously been started to be processed by any other available</span>
        <span class="slc">// threads).</span>
        pragma <span class="str">&quot;omp single nowait&quot;</span>
        {
            longLivedTree = <span class="kwd">createTree</span>(maximumTreeDepth, memoryPool);
            longLivedTreeChecksum = <span class="kwd">computeTreeChecksum</span>(longLivedTree);
        }

        <span class="slc">// Create a threadMemoryPool for this thread to use.</span>
        let threadMemoryPool: &amp;apr_pool_t;
        <span class="kwd">apr_pool_create_unmanaged</span>(&amp;threadMemoryPool);

        pragma <span class="str">&quot;omp for nowait&quot;</span>
        <span class="kwa">for</span>(let treeDepth = minimumTreeDepth; treeDepth &lt;= maximumTreeDepth; treeDepth += <span class="num">2</span>) {
            <span class="slc">// Create a bunch of binary trees of depth treeDepth, compute their</span>
            <span class="slc">// checksums, and add the checksums to the totalTreesChecksum.</span>
            let totalTreesChecksum = <span class="num">0</span>;
            <span class="kwa">for</span>(let iterations = <span class="num">1</span>&lt;&lt;(maximumTreeDepth-treeDepth+minimumTreeDepth); iterations-- &gt; <span class="num">0</span>;) {
                <span class="kwd">apr_pool_clear</span>(threadMemoryPool);
                totalTreesChecksum += <span class="kwd">computeTreeChecksum</span>(<span class="kwd">createTree</span>(treeDepth, threadMemoryPool));
            }

            <span class="slc">// Record the totalTreesChecksum for the trees of depth</span>
            <span class="slc">// treeDepth.</span>
            treeChecksums[(treeDepth-minimumTreeDepth)/<span class="num">2</span>] = totalTreesChecksum;
        }

        <span class="kwd">apr_pool_destroy</span>(threadMemoryPool);
    }

    <span class="slc">// Print the statistics for all of the various tree depths.</span>
    <span class="kwa">for</span>(let treeDepth = minimumTreeDepth; treeDepth &lt;= maximumTreeDepth; treeDepth += <span class="num">2</span>) {
        <span class="kwd">printf</span>(<span class="str">&quot;%jd</span><span class="esc">\t</span> <span class="str">trees of depth %jd</span><span class="esc">\t</span> <span class="str">check: %jd</span><span class="esc">\n</span><span class="str">&quot;</span>,
                <span class="num">1</span>&lt;&lt;(maximumTreeDepth-treeDepth+minimumTreeDepth),
                treeDepth,
                treeChecksums[(treeDepth-minimumTreeDepth)/<span class="num">2</span>]);
    }

    <span class="kwd">printf</span>(<span class="str">&quot;long lived tree of depth %jd</span><span class="esc">\t</span> <span class="str">check: %jd</span><span class="esc">\n</span><span class="str">&quot;</span>,
            maximumTreeDepth,
            longLivedTreeChecksum);
    <span class="kwd">apr_pool_destroy</span>(memoryPool);

    <span class="kwd">apr_terminate</span>();
    <span class="kwa">return</span> <span class="num">0</span>;
}
