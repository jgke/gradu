<span class="slc">// The Computer Language Benchmarks Game</span>
<span class="slc">// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/</span>
<span class="slc">//</span>
<span class="slc">// Contributed by Jeremy Zerfas</span>
<span class="slc">// Based on the C++ program from Jon Harrop, Alex Mizrahi, and Bruno Coutinho.</span>

<span class="ppc">#include &lt;stdint.h&gt;</span>
<span class="ppc">#include &lt;stdlib.h&gt;</span>
<span class="ppc">#include &lt;stdio.h&gt;</span>
<span class="ppc">#include &lt;apr_pools.h&gt;</span>

<span class="slc">// intptr_t should be the native integer type on most sane systems.</span>
<span class="kwc">typedef</span> <span class="kwb">intptr_t</span> intnative_t;

<span class="kwc">typedef</span> <span class="kwb">struct</span> TreeNode{
	<span class="kwb">struct</span> TreeNode *left, *right;
} TreeNode;


<span class="slc">// Create a binary tree of depth treeDepth in memoryPool and return a pointer</span>
<span class="slc">// to the created binary tree.</span>
<span class="kwb">static</span> TreeNode * <span class="kwd">createTree</span>(<span class="kwb">const</span> intnative_t treeDepth, apr_pool_t * <span class="kwb">const</span> memoryPool) {
    TreeNode * <span class="kwb">const</span> rootNode = <span class="kwd">apr_pcalloc</span>(memoryPool, <span class="kwa">sizeof</span>(TreeNode));

    <span class="slc">// If treeDepth is one or more then recursively call createTree() in order</span>
    <span class="slc">// to create the left and right subtrees.</span>
    <span class="kwa">if</span>(treeDepth&gt;<span class="num">0</span>){
        rootNode-&gt;left=<span class="kwd">createTree</span>(treeDepth-<span class="num">1</span>, memoryPool);
        rootNode-&gt;right=<span class="kwd">createTree</span>(treeDepth-<span class="num">1</span>, memoryPool);
    }

    <span class="kwa">return</span> rootNode;
}


<span class="slc">// Compute and return the checksum for the binary tree that has rootNode as the</span>
<span class="slc">// root node.</span>
<span class="kwb">static</span> intnative_t <span class="kwd">computeTreeChecksum</span>(<span class="kwb">const</span> TreeNode * <span class="kwb">const</span> rootNode){
    <span class="slc">// If there are subtrees then recursively call computeTreeChecksum() on</span>
    <span class="slc">// them and return 1 plus the checksum of those subtrees.</span>
    <span class="kwa">if</span>(rootNode-&gt;left &amp;&amp; rootNode-&gt;right)
        <span class="kwa">return</span> <span class="kwd">computeTreeChecksum</span>(rootNode-&gt;left)+
            <span class="kwd">computeTreeChecksum</span>(rootNode-&gt;right)+<span class="num">1</span>;

    <span class="slc">// If the function gets here then this is a single node tree so just return</span>
    <span class="slc">// 1 as the checksum.</span>
    <span class="kwa">return</span> <span class="num">1</span>;
}


<span class="kwb">int</span> <span class="kwd">main</span>(<span class="kwb">int</span> argc, <span class="kwb">char</span> *argv[]){
    <span class="slc">// Set minimumTreeDepth to 4 and maximumTreeDepth to the maximum of what</span>
    <span class="slc">// was specified as the argument to the program and minimumTreeDepth+2.</span>
    <span class="kwb">const</span> intnative_t minimumTreeDepth=<span class="num">4</span>, 
          maximumTreeDepth=<span class="kwd">atoi</span>(argv[<span class="num">1</span>])&lt;minimumTreeDepth+<span class="num">2</span> ?
              minimumTreeDepth+<span class="num">2</span> : <span class="kwd">atoi</span>(argv[<span class="num">1</span>]);

    <span class="kwd">apr_initialize</span>();

    <span class="slc">// Create a memoryPool which will be used for storing both the stretchTree</span>
    <span class="slc">// and the longLivedTree.</span>
    apr_pool_t * memoryPool;
    <span class="kwd">apr_pool_create_unmanaged</span>(&amp;memoryPool);

    <span class="slc">// Create a stretchTree of depth maximumTreeDepth+1, compute its</span>
    <span class="slc">// checksum, and print its statistics. This work could be done in parallel</span>
    <span class="slc">// along with all the other tree processing but APR memory pools aren&apos;t</span>
    <span class="slc">// quite as streamlined as other memory pool implementations so it uses less</span>
    <span class="slc">// resources to do this work by itself and then clear the memoryPool so</span>
    <span class="slc">// that most of the memory that was already allocated for the stretchTree</span>
    <span class="slc">// can be reused for the upcoming longLivedTree work rather than having</span>
    <span class="slc">// APR allocate more memory for memory pools. Unfortunately since the</span>
    <span class="slc">// longLivedTree is about half the size of the stretchTree, this ends up</span>
    <span class="slc">// wasting about half the memory that was being used by the stretchTree.</span>
    <span class="slc">// APR subpools could be used to use that otherwise wasted memory for the</span>
    <span class="slc">// processing of other trees that will be done later but it appears subpools</span>
    <span class="slc">// only work with managed pools (even though APR&apos;s documentation for the</span>
    <span class="slc">// apr_pool_create_unmanaged_ex() function seems to suggest that it possibly</span>
    <span class="slc">// should work for unmanaged pools too) which are noticeably slower than</span>
    <span class="slc">// unmanaged memory pools.</span>
    TreeNode * stretchTree=<span class="kwd">createTree</span>(maximumTreeDepth+<span class="num">1</span>, memoryPool);
    <span class="kwd">printf</span>(<span class="str">&quot;stretch tree of depth %jd</span><span class="esc">\t</span> <span class="str">check: %jd</span><span class="esc">\n</span><span class="str">&quot;</span>,
            (<span class="kwb">intmax_t</span>)maximumTreeDepth+<span class="num">1</span>,
            (<span class="kwb">intmax_t</span>)<span class="kwd">computeTreeChecksum</span>(stretchTree));
    <span class="kwd">apr_pool_clear</span>(memoryPool);

    <span class="slc">// The longLivedTree will be created in just a little bit simultaneously</span>
    <span class="slc">// (assuming OpenMP was enabled and the program is running on a multi-</span>
    <span class="slc">// processor system) while the rest of the trees are also being processed.</span>
    <span class="slc">// longLivedTree will store the reference to it which will remain valid</span>
    <span class="slc">// until near the end of the program.</span>
    TreeNode * longLivedTree;

    <span class="slc">// These will be used to store checksums for the various trees so the</span>
    <span class="slc">// statistics for the various trees can be output in the correct order</span>
    <span class="slc">// later.</span>
    intnative_t longLivedTreeChecksum,
                treeChecksums[(maximumTreeDepth-minimumTreeDepth+<span class="num">2</span>)/<span class="num">2</span>];
<span class="ppc">#pragma omp parallel</span>
    {
        <span class="slc">// Have one thread create the longLivedTree of depth</span>
        <span class="slc">// maximumTreeDepth in the memoryPool which was already previously</span>
        <span class="slc">// used for the stretchTree, compute the longLivedTreeChecksum, and</span>
        <span class="slc">// then just leave the longLivedTree alone for a while while the rest</span>
        <span class="slc">// of the binary trees finish processing (which should have</span>
        <span class="slc">// simultaneously been started to be processed by any other available</span>
        <span class="slc">// threads).</span>
<span class="ppc">#pragma omp single nowait</span>
        {
            longLivedTree=<span class="kwd">createTree</span>(maximumTreeDepth, memoryPool);
            longLivedTreeChecksum=<span class="kwd">computeTreeChecksum</span>(longLivedTree);
        }

        <span class="slc">// Create a threadMemoryPool for this thread to use.</span>
        apr_pool_t * threadMemoryPool;
        <span class="kwd">apr_pool_create_unmanaged</span>(&amp;threadMemoryPool);

<span class="ppc">#pragma omp for nowait</span>
        <span class="kwa">for</span>(intnative_t treeDepth=minimumTreeDepth;
                treeDepth&lt;=maximumTreeDepth; treeDepth+=<span class="num">2</span>){

            <span class="slc">// Create a bunch of binary trees of depth treeDepth, compute their</span>
            <span class="slc">// checksums, and add the checksums to the totalTreesChecksum.</span>
            intnative_t totalTreesChecksum=<span class="num">0</span>;
            <span class="kwa">for</span>(intnative_t iterations=
                    <span class="num">1</span>&lt;&lt;(maximumTreeDepth-treeDepth+minimumTreeDepth);
                    iterations--&gt;<span class="num">0</span>;){
                <span class="kwd">apr_pool_clear</span>(threadMemoryPool);
                totalTreesChecksum+=<span class="kwd">computeTreeChecksum</span>(
                        <span class="kwd">createTree</span>(treeDepth, threadMemoryPool));
            }

            <span class="slc">// Record the totalTreesChecksum for the trees of depth</span>
            <span class="slc">// treeDepth.</span>
            treeChecksums[(treeDepth-minimumTreeDepth)/<span class="num">2</span>]=
                totalTreesChecksum;
        }

        <span class="kwd">apr_pool_destroy</span>(threadMemoryPool);
    }

    <span class="slc">// Print the statistics for all of the various tree depths.</span>
    <span class="kwa">for</span>(intnative_t treeDepth=minimumTreeDepth;
            treeDepth&lt;=maximumTreeDepth; treeDepth+=<span class="num">2</span>)
        <span class="kwd">printf</span>(<span class="str">&quot;%jd</span><span class="esc">\t</span> <span class="str">trees of depth %jd</span><span class="esc">\t</span> <span class="str">check: %jd</span><span class="esc">\n</span><span class="str">&quot;</span>,
                (<span class="kwb">intmax_t</span>)<span class="num">1</span>&lt;&lt;(maximumTreeDepth-treeDepth+minimumTreeDepth),
                (<span class="kwb">intmax_t</span>)treeDepth,
                (<span class="kwb">intmax_t</span>)treeChecksums[(treeDepth-minimumTreeDepth)/<span class="num">2</span>]);

    <span class="kwd">printf</span>(<span class="str">&quot;long lived tree of depth %jd</span><span class="esc">\t</span> <span class="str">check: %jd</span><span class="esc">\n</span><span class="str">&quot;</span>,
            (<span class="kwb">intmax_t</span>)maximumTreeDepth,
            (<span class="kwb">intmax_t</span>)longLivedTreeChecksum);
    <span class="kwd">apr_pool_destroy</span>(memoryPool);

    <span class="kwd">apr_terminate</span>();
    <span class="kwa">return</span> <span class="num">0</span>;
}
