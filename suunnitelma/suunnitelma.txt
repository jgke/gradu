C-ohjelmointikielen korvaajiksi tehdyt ohjelmointikielet ja miksi C on niistä huolimatta käytössä
Jaakko Hannikainen

Helsinki 17.3.2018 Pro gradu -tutkielmasuunnitelma HELSINGIN YLIOPISTO Tietojenkäsittelytieteen laitos

HELSINGIN YLIOPISTO -- HELSINGFORS UNIVERSITET -- UNIVERSITY OF HELSINKI
Tiedekunta -- Fakultet -- Faculty Laitos -- Institution -- Department

Matemaattis-luonnontieteellinen tiedekunta
Tekijä -- Författare -- Author

Tietojenkäsittelytieteen laitos

Jaakko Hannikainen
Työn nimi -- Arbetets titel -- Title

C-ohjelmointikielen korvaajiksi tehdyt ohjelmointikielet ja miksi C on niistä huolimatta käytössä
Oppiaine -- Läroämne -- Subject

Tietojenkäsittelytiede
Työn laji -- Arbetets art -- Level Aika -- Datum -- Month and year Sivumäärä -- Sidoantal -- Number of pages

Pro gradu -tutkielmasuunnitelma 17.3.2018
Tiivistelmä -- Referat -- Abstract

16 sivua + 1 liitesivu

Tutkielman tiivistelmä. ACM Computing Classification System (CCS): Software and its engineering  Software notations and tools  General programming languages  Language types  Imperative languages Software and its engineering  Software organization and properties  Operating systems Computer systems organization  Embedded and cyber-physical systems  Embedded systems  Embedded software

Avainsanat -- Nyckelord -- Keywords

C, ohjelmointikielet
Säilytyspaikka -- Förvaringsställe -- Where deposited

Muita tietoja -- övriga uppgifter -- Additional information

Sisältö
1 Johdanto 2 Määritelmät 2.1 C:hen verrattavissa olevat ohjelmointikielet . . . . . . . . . . . . . . . 3 Olemassa olevat ohjelmointikielet 3.1 Yleisiä vertailtavien ohjelmointikielten ominaisuuksia 3.2 C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.3 Ada . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.4 C++ . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.5 D . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.6 Go . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.7 Rust . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 Uudelta kieleltä vaadittavat 4.1 Ominaisuuksia . . . . . . . 4.2 Syntaksi . . . . . . . . . . 4.3 Toolaus . . . . . . . . . . 5 Tutkielman rakenne Lähteet Liitteet 1 GitHub -verkkopalvelun eniten käytetyt lisenssit 1 2 3 4 4 4 6 6 7 7 8

. . . . . . .

. . . . . . .

. . . . . . .

. . . . . . .

. . . . . . .

. . . . . . .

. . . . . . .

. . . . . . .

. . . . . . .

ominaisuudet 9 . . . . . . . . . . . . . . . . . . . . . . . . 9 . . . . . . . . . . . . . . . . . . . . . . . . 10 . . . . . . . . . . . . . . . . . . . . . . . . 12 14 15

ii

1

1

Johdanto

C (ISO/IEC, 2011) on ollut vallitseva ohjelmointikieli järjestelmäohjelmoinnissa C:n alkuajoista lähtien. Useita ohjelmointikieliä on luotu historian saatossa, joiden oli tarkoitus syrjäyttää C, mutta C on vieläkin johtavana kielenä varsinkin sulautetuissa järjestelmissä ja UNIX-pohjaisten käyttöjärjestelmien vallitsevana ohjelmointikielenä. C on myös käytössä Windows-käyttöjärjestelmäperheen ydinkomponenttien toteutuksessa. Tässä opinnäytetyössä tutkitaan, miksi vaihtoehdoista huolimatta C on vieläkin laajalti käytössä myös uusissa projekteissa ja minkälainen ohjelmointikieli voisi syrjäyttää C:n. C:n vaihtoehdoiksi tutkitaan seuraavia tehokkaaseen ohjelmointiin tarkoitettuja kieliä: Ada (ISO/IEC, 2012), C++ (ISO/IEC, 2014), D (Bright & Alexandrescu, 2016), Go (Google, Inc., 2016) sekä Rust (Hoare, 2017a). Näistä kielistä tutkitaan, mikä tai mitkä ominaisuudet ovat estäneet C:n korvaamisen ja mitkä ominaisuudet ovat olleet parannuksia C:hen verrattuna. Lisäksi tutkitaan muista suosituista ohjelmointikielistä korkean tason ominaisuuksia, jotka ovat hyödyllisiä matalan tason ohjelmoinnissa ja jotka voi toteuttaa korvaavan kielen määrittelyssä luotujen rajoitusten puitteissa. rajoitteissa -> yhteydessä: minusta 'rajoitteissa' on parempi, sillä kieli speksataan tietyillä rajoitteilla (muistinkäyttö yms.) - tuo lause voisi tietysti reflektoida tätä ('...toteuttaa korvaavan kielen määrittelyssä luotujen rajoitusten puitteissa' tjsp.) Muutin tämän nyt tuohon muotoon (ennen: '...toteuttaa korvaavan kielen rajoitteissa.') Tutkittavana on myös, mitä optimointeja C:ssä ei voi tehdä helposti johtuen kielen rajoitteista ja miten tämän voisi korjata. Näitä ominaisuuksia ovat esimerkiksi sivuvaikutuksettoman ohjelmakoodin merkitseminen, optimointivinkkien alustariippumaton ilmaiseminen (esimerkiksi Rustin tavalla funktioiden annotointi) ja funktioiden yliajaminen1 riippuen parametrien tyypistä tai arvoista, mikäli ne voidaan kääntöaikaisesti päätellä. Koska C:n spesifikaatio ei salli useita samannimisiä funktioita, kääntäjä ei voi helposti optimoida tällaisia tapauksia. Tämän tutkielmasuunnitelman toisessa luvussa määritellään, minkälaiset ominaisuudet tarvitaan kieleltä, joka voisi korvata C:n kokonaan. Toisessa luvussa esitetään myös tutkielman kannalta oleellinen teoria, eli ohjelmointikielten nykypäivää sekä kerrotaan lyhyesti muista tutkittavista kielistä. Kolmannessa luvussa kerrotaan, miksi muut tutkitut kielet eivät täytä näitä ominaisuuksia, ja miten C:tä voisi parantaa. Neljännessä luvussa kuvaillaan toisen luvun määrittämien ominaisuuksien täyttävä ohjelmointikieli. Viidennessä luvussa kerrotaan tutkielman rakenne. Lopettavassa luvussa kerrataan tutkielman tavoitteet, vaiheet ja tulokset sekä pohditaan tutkielman puutteita ja jatkotutkimuskohteita.

1

eng. function overloading

2

2

Määritelmät

Verrattavissa ohjelmointikielissä on yritetty parantaa C:n huonoja puolia hyvien puolien kustannuksella, usein lisäämällä kieleen turvallisuutta parantavia ominaisuuksia. Tämä kuitenkin heikentää kielen tehokkuutta tai alustayhteensopivuutta tehden kielten suorasta vertailusta mahdotonta. Jos määritellään absoluuttiset reunaehdot, voidaan näiden puitteissa vertailla kieliä. Määritellään C:tä paremmaksi kieleksi kieli, joka C:hen verrattuna aina: · on yhtä nopea tai nopeampi · käyttää saman verran muistia tai vähemmän · toimii kaikissa järjestelmissä, joissa C toimii · on helpompi käyttää Jos yksikin näistä kriteereistä ei pidä, verrattava kieli ei ole absoluuttisesti C:tä parempi. On huomioitava, että lukuisten olemassa olevien C:n kirjastojen, rajapintojen ja projektien vuoksi yhteensopivuus C:n kanssa tulee olla saumatonta mahdollisten vaihtoehtoisten ohjelmointikielten osalta, jotta kielen vaihtaminen olisi mahdollista. Tämä sisältää myös kirkastorutiinien kutsumisen muista ohjelmointikielistä, sillä C on lukuisissa järjestelmissä lingua franca, jonka avulla ohjelmointikielet pystyvät kommunikoimaan keskenään. Esimerkiksi Python-ohjelmointikieli (Python Software Foundation, 2018b) sisältää tuen C-funktioiden kutsumiseen (Python Software Foundation, 2018a), jota voi käyttää muiden ohjelmointikielten funktioiden kutsumiseen, mikäli käyttäjä kirjoittaa 'sillan' C-ohjelmana. Ohjelmointikielten ekosysteemit koostuvat eri tahojen luomista kirjastoista. On tärkeää, että näihin kirjastoihin pääsee käsiksi mahdollisimman helposti. Tämä vaatii toimiakseen hyvät työkalut, kuten paketinhallintajärjestelmän2 , hyvän käännöstyökalun sekä kehitysympäristöt. paketinhallinta -> pakkaushallinta: 'paketinhallinta' on yleisesti käytössä oleva termi, ks. esim https://www.debian.org/index.fi.html https://fi.wikipedia.org/wiki/Paketinhallintaj%C3%A4rjestelm%C3%A4 Onhan se tietenkin hassu käännöksenä, kun pakkaus olisi 'oikeampi' käännös englannin package-sanasta, mutta luonnolliset kielet eivät toimi loogisesti. Kirjastojen lisenssien tulee myös olla yhteensopivia, jotta kirjastoja voi käyttää yhdessä toistensa kanssa. Eri ohjelmointikieliekosysteemeissä on käytössä erilaisia lisenssejä ­ JavaScript-kirjastot ovat usein MIT-yhteensopivia, kun taas Java-kirjastot ovat usein Apache 2 -yhteensopivia. Liitteessä 1 on taulukko GitHub-verkkopalvelun sisältämien julkisten projektien määrä ryhmiteltynä lisenssin ja kielen mukaan.
2

eng. package manager

3 Kirjastot voi myös julkaista useammalla kuin yhdellä lisenssillä, jolloin käyttäjät voivat päättää, mitä lisenssiä haluaa seurata. On kuitenkin filosofinen kysymys, onko esimerkiksi Apache2+GPL parempi lisenssi kuin pelkkä GPL, sillä Apache2 ei vaadi tiettyjä oikeuksia loppukäyttäjille, kuten pääsyä ohjelmiston lähdekoodiin (FOSSA, Inc., 2015a, 2015b).

2.1

C:hen verrattavissa olevat ohjelmointikielet

C:n suosiosta johtuen historian saatossa on tehty useita C:n kilpailijoita, jotka ovat yrittäneet parantaa C:tä joidenkin C:n hyvien puolien kustannuksella. Muutamat näistä ovat päätyneet hyvin suosituiksi ohjelmointikieliksi, kuten esimerkiksi C++ ja Go. Kielten suosion mittaamiseen on tehty useita projekteja, jotka vertailevat kieliä esimerkiksi hakutulosten tai projektien mukaan. Näitä ovat esimerkiksi TIOBEn ohjelmointikielten suosion indeksi (TIOBE software BV, 2018) ja GitHubin julkaisema Octoverse (GitHub, Inc., 2017). Valitsemalla vertailuun suosittuja kieliä voidaan tutkia, miksi muuten selkeästi täysin käyttökelpoinen kieli ei ole syrjäyttänyt C:tä. Koska C on yksi suorituskyvyltään nopeimmista ohjelmointikielistä, on myös tärkeää rajata vertailuun vain muita nopeita kieliä ­ korkeamman tason ohjelmointikielet on tarkoitettu ohjelmointinopeuden parantamiseen. Tällöin suorituskyky on jäänyt vähemmälle, koska on usein halvempaa optimoida kirjoittamiseen käytettyä aikaa kuin nopeuttaa suorituskykyä muutamalla prosentilla [citation_needed]. Yksi kattava suorituskykyä mittaava vertailu on Benchmarks game (Gouy, 2018), jossa pyritään kirjoittamaan mahdollisimman nopea ohjelma pysyen silti kielelle idiomaattisessa ohjelmakoodissa. Ada, C++, D, Go ja Rust nousevat esiin näistä kolmesta vertailusta. Kaikki viisi kieltä ovat sekä suosittuja että tehokkaita. Lähivuosina on tehty myös useita C:hen käännettäviä ohjelmointikieliä, jotka ovat jääneet pitkälti ilman mitään näkyvyyttä, kuten LISP/c (Baca, 2016), C-Mera (kiselgra, 2018) ja Nymph (Barber, 2017). LISP/c ja C-Mera ovat LISP-perheeseen kuuluvia C:ksi kääntyviä ohjelmointikieliä, jotka on suunniteltu etupäässä parantamaan C:n syntaksia rikkaammalla makrojärjestelmällä. Nymph taas on olio-ohjelmointikieli. Tässä voisi olla jotain pohdintaa, miksi nuo ovat jääneet huomiotta ja miten tämän voisi välttää... Tai sitten poistaa tuon viimeisen kappaleen kokonaan.

4

3
3.1

Olemassa olevat ohjelmointikielet
Yleisiä vertailtavien ohjelmointikielten ominaisuuksia

Miten tarkasti näitä pitää perustella/kaivaa lähteitä? Vertailtavissa ohjelmointikielissä on yleisesti useita ominaisuuksia, jotka vaikuttavat ohjelmien ajoaikaiseen nopeuteen hidastavasti. Yleisin näistä on automaattinen muistinhallinta, joka lisää "roskien keräämisen"3 , jonka ajaksi ohjelman suoritus pysäytetään4 . Lisäksi automaattinen muistinhallinta lisää muistinkäyttöä, sillä ohjelmointikieli joutuu ajoaikaisesti määrittämään käytössä olevat muistiosoitteet. Moderneissa ohjelmointikielissä virheiden käsittely on lähes poikkeuksetta toteutettu poikkeuksilla. Poikkeusten käsittely vaatii pienen määrän muistia jokaiselta funktiokutsulta, sillä poikkeuksen tapahtuessa ohjelman pitää löytää lähin poikkeuskäsittelijä ­ tämä tapahtuu kävelemällä pinoa takaisin ylöspäin, kunnes poikkeuskäsittelijä löytyy. Jos virheiden käsittely on taas toteutettu esimerkiksi signaaleilla, pinoa ei tarvitse kävellä, sillä vain yksi signaalinkäsittelijä voi kerrallaan olla käytössä jokaista signaalia kohden. Ohjelmointikieli voi toteuttaa olio-ohjelmoinnin rajapinnat käytännössä kahdella tavalla: Joko korvaamalla jokaisen rajapintaviittauksen numerolla jaettuun tauluun funktioita (vtable-rajapinnat), tai korvaamalla rajapintaviittaukset tietueella, joka sisältää rajapinnan toteutuksen funktioiden osoitteet (tietue-rajapinnat). Ensimmäistä käytetään eritoten C++:n rajapintojen toteuttamiseen, kun taas jälkimmäistä käytetään esimerkiksi Gossa. Jälkimmäistä käytetään myös C:n kanssa; Linux-ytimen laiteajurit on toteutettu tietue-rajapintoina, joita ajurit voivat tarvittaessa periä. Molemmissa toteutustavoissa on omat hyvät jä huonot puolensa ­ vtable-rajapinnat vievät vähemmän muistia, kun taas tietue-rajapinnat ovat yksinkertaisempia toteuttaa ja hieman nopeampia [citation_needed]. Kumpi on suositumpi käännös nykyään, rajapinta vai liittymä?

3.2

C

C on lähes kaikkien järjestelmien ymmärtämä ohjelmointikieli, jota käytetään nopeutta tai pientä muistijalanjälkeä vaativien sovelluksien toteuttamiseen. C on suunniteltu olemaan mahdollisimman alustariippumaton, mutta jos tämä aiheuttaa ristiriidan mahdollisimman nopean toteutuksen kanssa, suositaan nopeutta. Tästä yleisin esimerkki on kokonaislukujen ylivuoto, jonka tulos riippuu kääntäjäoptimoinnista:

3 4

eng. garbage collection, gc eng. gc pause

5 #include <stdio.h> #include <limits.h> void print_if_overflow(int x) { if(x + 1 <= x) printf("Overflow\n"); else printf("Variable did not overflow\n"); } int main(int argc, char *argv[]) { print_if_overflow(INT_MAX); } $ cc -O0 c-overflow.c $ ./a.out Overflow $ cc -O3 c-overflow.c $ ./a.out Variable did not overflow

Kuva 1: Kokonaisluvun ylivuoto C-kielessä. Ylivuodon käyttäytyminen riippuu kääntäjäoptimoinnin määrästä ­ kääntäjän optimointitasolla -O0 lauseketta x + 1 <= x ei optimoida pois, mutta optimointitasolla -O3 kääntäjä 'tietää' että operaation +1 jälkeen kokonaisluvut eivät ylivuoda, sillä C-kielen spesifikaatiossa kokonaislukujen ylivuoto on "määrittelemätöntä toimintaa" (eng. undefined behavior). Luonnollisten lukujen yli- ja alivuoto taas on määritelty - luonnolliset luvut on määritelty renkaaksi. Miten koodiesimerkit tulisi merkitä? LaTeXin \caption antaa oletuksella käännökseksi 'Kuva', mikä ei nyt pidä paikkaansa kun tuo on kuitenkin tekstiä :) 'Lähdekoodi 1'? Jossain oli sivulauseessa että koodiesimerkit pitäisi käydä rivi riviltä läpi, miten rivi riviltä tämä oikeasti on? Selitänkö että 'void print_if_overflow(int x)' määrittelee funktion yms., vai riittääkö tuo nykyisen tasoinen selitys tällaisissa kohtalaisen yksinkertaisissa asioissa?

6 #include <stdio.h> #define DOUBLE(x) x*2 int main(int argc, char *argv[]) { printf("one plus one doubled is %d\n", DOUBLE(1+1)); } $ cc c-hygiene.c $ ./a.out one plus one doubled is 3

Kuva 2: C:n makrot eivät ole hygieenisiä. DOUBLE-makro muuttuu käännösvaiheessa muotoon 1+1*2, mikä on laskujärjestyksen takia 3 eikä odotettu 4. Koko printfkutsuksi muodostuu siis 'printf("one plus one doubled is %d", 1+1*2)' C:n makrot ovat muutenkin rajoittuneita ­ esimerkiksi rekursiivisten makrojen rakentaminen on liki mahdotonta.

3.3

Ada

Aliluvut eivät ole erityisen tasapainoisia keskenään ­ c-luku on huomattavasti pidempi johtuen koodiesimerkeistä Onko yleislöpinäkappaleet turhia, eli esim. alla oleva kuka teki, miksi, milloin? Ada on Yhdysvaltain puolustusministeriön kehittämä ohjelmointikieli, joka suunniteltiin korvaamaan kaikki muut puolustusministeriön käyttämät ohjelmointikielet [citation_needed].Ada on hyvin moneen taipuva kieli, sillä se pystyy hallitsemaan monia eri käyttötarkoituksia matalan tason bittitason ohjelmoinnista korkean tason arkkitehtuureihin [citation_needed]. Ohjelmoinnin tehostamiseksi Adassa on sekä poikkeukset että automaattinen muistinhallinta. Nämä kuitenkin hidastavat kieltä hieman. Lisäksi C-kielen kanssa yhteensopivuus on kielen taipuvuudesta johtuen hankalaa - jokainen kutsuttava C-funktio on yksitellen määritettävä kutsukonvention5 kanssa, sillä kutsukonventiot eivät ole alustariippumattomia [citation_needed].

3.4

C++

C++ on Bjarne Stroustrupin 1980-luvusta eteenpäin kehittämä kieli, jonka tarkoituksena on yhdistää C:n nopeus luokkapohjaisen olio-ohjelmoinnin helppokäyt5

eng. calling convention

7 töisyyteen [citation_needed]. C++ on nykypäivänä suosittu tehokkuutensa ja monipuolisuutensa takia monimutkaisissa ohjelmistoissa, kuten palvelinohjelmistoissa ja peleissä [citation_needed]. C++ on kehitetty C:n pohjalta, ja siinä onkin erittäin hyvä C-tuki. Johtuen nimiruntelusta6 , joka on C++:ssa oletuksella päällä, C-koodin otsikkotiedostoissa7 on usein alussa C++-koodia, joka laittaa nimiruntelun pois päältä. Näin C++-ohjelmat voivat helposti kutsua C-ohjelmien kirjastokutsuja ­ C++-ohjelmat ymmärtävät suoraan C-kielen otsikkotiedostoja. Virheidenkääsittely on toteutettu poikkeuksilla, jotka aiheuttavat pienen hidastuksen. C++:ssa on myös käytettävissä viitemäärälaskettu8 automaattinen muistinhallinta, jolla voidaan käyttää ajoaikaisesti varattua muistia ilman muistivuotoja. C++:ssa tosin ei ole roskien keräystä, vaan kun viimeinen viite olioon poistetaan, myös varattu muisti vapautetaan ­ tällöin ohjelman suorituksen aikana ei tule roskienkeräystaukoja.

3.5

D

D on 2000-luvun alussa Digital Mars -yrityksen julkaisema ohjelmointikieli, jonka tarkoituksena on yksinkertaistaa C++-koodia [citation_needed]. Vaikka D-kielessä on automaattinen muistinhallinta, D:n 'BetterC' -tila poistaa käytöstä alustariippuvaiset ominaisuudet (D Language Foundation, 2016). Tällöin kielestä poistuu useita ominaisuuksia, mutta esimerkiksi D:n makrojärjestelmää voi käyttää. C-koodin kutsuminen on melko helppoa, mutta ei aivan saumatonta, sillä jokainen kutsuttava funktio tulee määritellä erikseen ­ D ei ymmärrä C:n otsikkotiedostoja. Tämä kuitenkin onnistuu yhdellä rivillä per funktio, sillä D:n tyyppijärjestelmä on hyvin lähellä C:tä.

3.6

Go

Taivutus; Go:ssa, Gossa, Go-kielessä, Golangissa...? Ainakin se lautapeli taivutetaan toisen mukaan ­ käytin nyt toista ja kolmatta muotoa sekaisin Go on Googlen 2000-luvun loppupuolella kehittämä ohjelmointikieli, jonka tarkoituksena on D:n tavoin korvata C++-koodia [citation_needed]. Go on suunniteltu mahdollisimman yksinkertaiseksi käyttää. Toisin kuin monissa moderneissa C-perheen kielissä, Gossa ei ole luokkia, vaan pelkkiä tietueita ja rajapintoja. Gossa ei ole mahdollista kirjoittaa käännösaikaisesti tyyppitarkistettua geneeristä koodia, mutta ohjelmat voivat ajoaikaisesti peilauksen9 kautta tutkia tietueiden rakennetta. Tämän mahdollistaminen kasvattaa ohjelmakoodin kokoa, sillä tietueiden
eng. name mangling ­ ei kai tämä ole oikeasti se suositeltu käännös? esim. mankelointi kuulostaa myös hassulta 7 eng. header file ­ ei kai tämäkään ole oikein suomennettu? Eihän? 8 eng. reference counting 9 eng. reflection
6

8 mukana on säilytettävä tietueen oikeaa tyyppiä. Gon virheidenkäsittely on toteutettu useissa kohdissa C:n tavoin; funktioista palautetaan virheellisissä tilanteissa virheellinen arvo. Tämä tosin tehdään usein palauttamalla erillinen Error-tyyppiä oleva arvo ­ Go mahdollistaa helposti useamman kuin yhden paluuarvon. Gossa on myös poikkeukset, joita suositellaan käyttävän vain poikkeuksellisissa tilanteissa [citation_needed]. C:n kutsuminen Gosta ei ole aukotonta: koska Go on muistinkäytöltä turvallinen kieli, erityisesti muistin jakaminen C:n ja Gon välillä on hankalaa [citation_needed]. C:n funktio-osoittimia ei voi kutsua Gon puolelta.

3.7

Rust

Rust on Mozilla Foundationin kehittämä ohjelmointikieli, joka on D:n ja Gon tavoin suunniteltu korvaamaan C++. Rust on suunniteltu kolmen ydinperiaatten ympärille; turvallisuuden, nopeuden ja rinnakkaisuuden [citation_needed]. Rustissa on monimutkainen tyyppijärjestelmä, jolla ohjelmat voivat todistaa esimerkiksi turvallisen rinnakkaisajon, ilman että ohjelmaan tulee ajoaikaisia rajoitteita tai hidastuksia. Rustin virheidenhallinta on lähellä Gon virhehallintaa ­ Rustin ohjekirja opastaa käyttämään mieluummin paluuarvoja kuin poikkeuksia [citation_needed]. Kuten Gossa, Rustissa voi myös käyttää poikkeuksia. Pitäisikö tässä olla vielä pohdintaa kielissä olevista yhteisistä piirteistä?

9

4
4.1

Uudelta kieleltä vaadittavat ominaisuudet
Ominaisuuksia

Uuden ohjelmointikielen tulee olla mahdollisimman yhteensopiva C:n kanssa. Tämä onnistuu parhaiten pitämällä ajoaikaisten ominaisuuksien määrän mahdollisimman pienenä. Muistinhallinnan tulee olla manuaalinen, jotta kutsuessa C-funktioita kielet voivat saumattomasti ja tehokkaasti jakaa osoitinmuuttujia. Moniajoa ei voi alustariippumattomuuden takia tukea suoraan standardikirjastossa, mutta spesifikaatio voi ehdottaa yhteistä rajapintaa moniajototeutuksille. Jotta kieltä voi käyttää nykyisissä ympäristöissä, sen tulee kääntyä C:ksi. Tällöin ohjelmointikieli toimii kaikissa ympäristöissä, joihin on olemassa C-standardin mukainen C-kääntäjä. Tämä mahdollistaa integroinnin nykyisten työkalujen kanssa ­ esimerkiksi Make-työkalulla [citation_needed]uuden kielen tiedostot voi kääntää kahdella rivillä rivillä: %.c : %.kieli kielic $< -o $@ Tämän jälkeen olemassaolevat .c-tiedostot voi poistaa, ja Make osaa luoda ne .kielitiedostojen pohjalta. Kääntäjän tulee tuottaa ylläpitokelpoisia .c-tiedostoja, jotta kielestä voi myös tarvittaessa siirtyä pois helposti. Kielen tulee myös tukea C:n otsikkotiedostoja, jotta ohjelmoijilta ei mene turhaan aikaa funktiomäärittelyiden kääntämiseen kieleltä toiselle. Vastaavasti kielen tulee myös tarvittaessa tuottaa C-kielen otsikkotiedostoja ­ näin voi helposti uudelleenkirjoittaa C-kirjastoja. Ohjelmointikielen nimi yms. työn alla Ajoaikaisen tyyppijärjestelmän tulee olla täysin yhteensopiva C:n kanssa. Esimerkki tällaisesta kielestä on TypeScript [citation_needed], joka lisää vahvan tyypityksen JavaScriptiin kuitenkin vaikuttamatta mitenkään ajoaikaisiin ominaisuuksiin. Myös Rustin ajoaikainen tyypitys on lähellä C:tä; Rustin Box<T> vaatii, että tyyppiparametrin arvo ei ole tyhjä 10 , jolloin laatikossa voi säilyttää C:n tavoin esimerkiksi merkkijonoja ­ tyhjä arvo vastaa C:n NULLia. Tyhjiä arvoja on kuvailtu "Miljoonan dollarin virheeksi" niiden keksijän toimesta (Hoare, 2009). Useat ohjelmointikielet ovatkin poistaneet muuttujilta mahdollisuuden olla tyhjiä arvoja, kuitenkin mahdollistaen tyhjät arvot esimerkiksi yhdellä merkillä lisää tyyppimäärittelyssä. Jos uuteen kieleen otetaan tällainen oletus, Cfunktiomäärittelyiden tulee saumattoman yhteistyön takia olla "limbossa" näiden kahden tilan välillä, sillä C:n syntaksi ei sisällä lupauksia mahdollisista tyhjistä arvoista ­ tai niiden puutteesta. Ohjelmoijaa siis ei voi pakottaa tarkistamaan tyhjiä arvoja, jos hän kutsuu jotain C-funktiota, mutta toisaalta ei myöskään varoittaa 'turhista' tarkistuksista.
10

NULL ­ onko tähän parempia käännöksiä?

10 Koska kieli voi vaikuttaa lähinnä käännösaikaisesti, tulee kielen makrojärjestelmän olla sekä turvallinen että voimakas. Rustin makrojärjestelmä on vahvasti tyypitetty sekä Turing-täydellinen (Hoare, 2017b). Tämä mahdollistaa myös monimutkaisten makrojen kirjoittamisen ja käytön. Rustin makrosyntaksi on kuitenkin ensisilmäyksellä vaikeaselkoista, kun taas C:n makrot ovat pitkälti helppolukuisia. C-kääntäjissä on aina alustariippuvaisia ominaisuuksia, ja yksi tärkeimmistä on funktioiden kutsuminen. GCC:n [citation_needed]kanssa yhteensopivat kääntäjät tukevat funktiomäärittelyn kohdalla __attribute__() -määrettä, joka kertoo, miten funktiolle tulisi antaa ajoaikaisesti parametrit. C++:n yksi tärkeistä ominaisuuksista on nimiavaruudet, joita C:ssä ei ole. Jos samassa ohjelmassa on kaksi samannimistä funktiota, ei ole määritelty, kumpaa niistä kutsutaan. C++:ssa ongelma on ratkaistu nimiruntelulla. Tämä on kuitenkin aiheuttanut ristiriitoja sekä C-yhteensopivuuden kanssa että eri C++-kääntäjien yhteensopivuuden kanssa.

4.2

Syntaksi

Jotta kielestä toiseen vaihtaminen olisi kannattavaa, uuden kielen on oltava tarpeeksi erilainen: samanlainen kieli ei tarjoa tarpeeksi parannusta olemassaolevaan, että siirtyminen olisi kannattavaa. C:n syntaksia on usein kritisoitu[citation_needed]vuolaudesta, joten syntaksia typistämällä voisi saada huomattavia parannuksia.

11 int strcmp(const char *a, const char *b) { while(*a && *b) { if(*a == *b) { a++; b++; } else { return *a - *b; } } return 0; } strcmp :: [Int] -> [Int] -> Int strcmp (a:as) (b:bs) = if a == b then strcmp as bs else a - b strcmp a b = head (a++[0]) - head (b++[0])

Kuva 3: C:n strcmp-funktio toteutettuna C:llä ja Haskellilla, jota voi käyttää merkkijonojen vertailuun. Ylempi on C-kieltä, kun taas alempi esimerkki on kirjoitettu Haskellilla. Käyn näitä tarkemmin läpi myöhemmin Jotta kieli on mahdollisimman kevyt ja alustariippumaton, kielen standardikirjaston tulee olla mahdollisimman kevyt. Kielen makrojärjestelmän tulee olla tarpeeksi voimakas, että alustariippuvaiset ominaisuudet voidaan toteuttaa puhtaasti kirjastotasolla. C:n tyyppisyntaksia on usein [citation_needed]kritisoitu. vaikka kielessä onkin sinänsnä järkevä logiikka tyyppimäärittelyyn: jos tyyppimäärittely on esimerkiksi int (*fp)(int arg, char arg2), kirjoittamalla koodiin (*fp)(int, char) saa arvon tyyppiä int. Monimutkaisissa tapauksissa on vaikeaa seurata tyypin oikeaa arvoa, ja monet ohjelmointikielet ovatkin kehittäneet vaihtoehtoisia tapoja merkitä tyyppejä. Modernimpi tapa ilmaista yllä oleva tyyppi on fp: (int, char) -> int. Yksi hyvin suosituista ominaisuuksista moderneissa ohjelmointikielissä on tyyppiinferenssi. Oikein käytettynä sillä voidaan poistaa lähdekoodista pääteltävissä olevat tyypit, jolloin ohjelmoija voi keskittyä ohjelmalogiikkaan. Tyyppi-inferenssi onkin erityisen kätevä lambdojen kirjoittamisessa, sillä ohjelmoijan ei tarvitse kirjoittaa täysin pääteltäviä tyyppejä. Toinen suosittu ominaisuus on hahmontunnistus11 , jolla voidaan kasvattaa kielen ilmaisuvoimaa. Kuvassa 3 Haskell-esimerkki käyttää hahmontunnistusta oikean
11

eng. pattern matching

12 funktion valitsemiseen. Gon yksi innovatiivisimmista ominaisuuksista on defer, jolla voidaan viivästyttää laskentaa funktiosta poistumiseen asti. Esimerkiksi A Tour of Go -sivuston esimerkissä (Google, Inc., 2018) käytetään deferiä Hello World -ohjelman toteuttamiseen: package main import "fmt" func main() { defer fmt.Println("world") fmt.Println("hello") } $ go run defer.go hello world

Kuva 4: defer-avainsana siirtää world-sanan tulostamisen funktion loppuun, jolloin ohjelma tulostaa sanat "hello" ja "world". Ilman automaattista muistinhallintaa kaikissa tilanteissa toimivaa deferiä ei voi toteuttaa, mutta yksinkertaisissa tilanteissa myös hyvin matalan tason kieli voisi toteuttaa defer-avainsanan. Avainsanalle tulisi käyttöä ­ esimerkiksi Linux-kernelissä on yleinen kuvio vapauttaa kaikki funktion varaama muisti käänteisessä järjestyksessä virhetilanteissa. Vain virhetilanteissa ajettu defer mahdollistaisi huomattavaa siivoamista ­ ohjelmoijan ei tarvitse ajatella muistin vapauttamista, sillä ohjelmointikieli tekee sen ohjelmoijan puolesta. Vielä monimutkaisempi tapaus on sulkeumat, joita suositaan erityisesti funktionaalisen ohjelmoinnin yhteydessä. GCC-kääntäjä on toteuttanut sulkeumat C-kielelle käyttämällä Thomas Breuelin esittelemää trampoliinimenetelmää (Breuel, 1988; Free Software Foundation, Inc., 2018).

4.3

Toolaus

Modernissa ohjelmointikielessä on tärkeänä osana kehittäjän hyvinvointi, jota voidaan ylläpitää hyvillä työkaluilla. Go-kieli kehitettiin yhdessä kattavan työkalupaketin kanssa, jolloin työkalut pysyivät mukana kielen kehityksessä. Gon mukana tuleekin nykyään kääntäjän (go build) yhteydessä mm. paketinhallinta go get, koodin automaattinen muotoilija go fmt sekä ohjelmointivirheiden tarkastaja go vet. Kirjoittamalla kääntäjän ensin C:llä ja vasta myöhemmin hiljalleen siirtymällä uuteen

13 kieleen voidaan esitellä kielen mahdollisuutta toimia C:n korvaajana.

14

5

Tutkielman rakenne

Tutkielman aloittavassa johdantokappaleessa perustellaan tutkielman tärkeys sekä kuvaillaan lopun tutkielman sisältö ja tutkimuskysymys. Toisessa kappaleessa esitetään tutkielman kannalta oleellinen teoria, eli C-kielen historiaa ja nykypäivää sekä pohditaan, minkälaiset ominaisuudet tarvittaisiin kieleltä, joka voisi korvata C:n kokonaan. Kolmannessa kappaleessa kerrotaan, miksi muut tutkitut kielet eivät täytä näitä ominaisuuksia. Neljännessä kappaleessa kuvaillaan kappaleen kolme käsittelemien ominaisuuksien täyttävä ohjelmointikieli. Lopettavassa kappaleessa kerrataan tutkielman tavoitteet, vaiheet ja tulokset sekä pohditaan tutkielman puutteita ja mahdollisia jatkotutkimuskohteita.

15

Lähteet
Baca, J. (2016). eratosthenesia/lispc: "Lispsy" Lisp(ish) to C Converter (designed for CLISP). https://github.com/eratosthenesia/lispc. Barber, B. (2017). roecrew/nymph: A slightly different version of c. https://github.com/roecrew/nymph. Breuel, T. M. (1988). Lexical Closures for C++. Teoksessa C++ Conference Proceedings (s. 293­304). USENIX Association. Bright, W., & Alexandrescu, A. e. a. (2016). D Programming Language. http://dlang.org/spec/spec.html. D Language Foundation. (2016). Better c - d programming language. https://dlang.org/spec/betterc.html. FOSSA, Inc. (2015a). Apache License 2.0 (Apache-2.0) Explained in Plain English TLDRLegal. https://tldrlegal.com/license/apache-license-2.0-(apache-2.0). FOSSA, Inc. (2015b). GNU General Public License v3 (GPL-3) Explained in Plain English - TLDRLegal. https://tldrlegal.com/license/gnu-general -public-license-v3-(gpl-3). Free Software Foundation, Inc. (2018). Using the gnu compiler collection (gcc): Nested functions. https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html. GitHub, Inc. (2017). GitHub Octoverse 2017 | Highlights from the last twelve months. https://octoverse.github.com/. Google, Inc. (2016). The Go Programming Language. https://golang.org/ref/spec. Google, Inc. (2018). A tour of go. https://tour.golang.org/. Gouy, I. (2018). The Computer Language Benchmarks Game. http://benchmarksgame.alioth.debian.org/. Hannikainen, J. (2018). licensescraper.sh. https://gist.github.com/jgke/087fe488542b284eee938ef3bf703f1f. Hoare, G. e. a. (2017a). Introduction - The Rust Reference. https://doc.rust-lang.org/reference/. Hoare, G. e. a. (2017b). Macros - the rust programming language. https:// doc.rust-lang.org/book/first-edition/macros.html#the-deep-end. Hoare, T. (2009). Null References: The Billion Dollar Mistake. https://www.infoq.com/presentations/Null-References-The-Billion -Dollar-Mistake-Tony-Hoare. ISO/IEC 14882:2014 ­ Information technology ­ Programming languages ­ C++ (Standard). (2014). Geneva, CH: International Organization for Standardization. ISO/IEC 8652:2012 ­ Information technology ­ Programming languages ­ Ada (Standard). (2012). Geneva, CH: International Organization for Standardization. ISO/IEC 9899:2011 ­ Information technology ­ Programming languages ­ C (Standard). (2011). Geneva, CH: International Organization for Standardization. kiselgra. (2018). kiselgra/c-mera. https://github.com/kiselgra/c-mera.

16 Python Software Foundation. (2018a). 16.16. ctypes A foreign function library for Python Python 3.6.4 documentation. https://docs.python.org/3/library/ctypes.html. Python Software Foundation. (2018b). Welcome to Python.org. https://www.python.org/. TIOBE software BV. (2018). TIOBE index. https://www.tiobe.com/tiobe-index.

1

Liite 1. GitHub -verkkopalvelun eniten käytetyt lisenssit
Tämä taulukko sisältää GitHub -verkkopalvelun avoimien projektien määrän ryhmiteltynä lisenssin ja kielen mukaan. Data on kasattu GitHubin APIa käyttämällä. Taulukosta on korostettu kunkin ohjelmointikielen 3 eniten käytettyä lisenssiä. Datan kerääjän lähdekoodi on saatavilla GitHubista (Hannikainen, 2018). Taulukko on koostettu 13. maaliskuuta 2018.

Ada afl-3.0 apache-2.0 artistic-2.0 bs1-1.0 bsd-2-clause bsd-3-clause bsd-3-clause-clear cc cc0-1.0 cc-by-4.0 cc-by-sa-4.0 wtfpl ecl-2.0 epl-1.0 eupl-1.1 agpl-3.0 gpl-2.0 gpl-3.0 lgpl lgpl-2.1 lgpl-3.0 isc lppl-1.3c ms-pl mit mpl-2.0 osl-3.0 postgresql ofl-1.1 ncsa unlicense zlib

C

C++

D

Go

Java JavaScript

Rust TypeScript 4 5179 5 0 149 500 1 148 130 9 9 73 1 19 10 430 321 3297 217 27 190 444 0 4 44623 170 4 0 2 0 525 9

0 20 52 4 3 40 34 12825 16873 133 21674 180463 0 216 173 3 35 485 0 0 0 0 0 0 8 5506 4385 64 3460 3425 38 8348 11714 103 6990 9309 0 8 81 0 3 22 1 691 698 11 220 1318 1 644 615 11 208 1158 0 17 25 0 8 54 0 30 58 0 4 106 4 572 554 7 316 826 0 4 12 0 4 59 1 260 251 9 98 5564 0 11 15 1 1 67 9 1291 1790 28 1064 3917 88 51476 23995 127 2358 26599 147 35742 47337 314 7120 64501 20 9267 9929 91 945 12163 7 5949 3914 28 110 3898 13 3318 6015 63 835 8265 38 1380 502 13 933 562 0 0 0 0 0 1 0 25 61 2 3 9 120 46706 78673 1247 62989 133001 1 641 1073 47 1307 1593 0 14 23 1 1 83 0 3 0 0 0 0 0 5 7 0 0 12 0 2 1 0 0 0 10 2737 3135 86 1365 5944 2 233 245 11 64 42

24 2 101277 3642 672 7 0 0 6656 359 18013 511 45 1 6368 100 5896 99 261 0 211 1 2214 97 69 0 1355 3 58 0 8264 271 26293 315 59684 1881 5390 236 989 63 4401 173 10381 239 0 0 94 0 710817 11816 5078 503 138 2 1 0 75 2 0 0 9903 480 84 11

