\section{Verrattavat ohjelmointikielet}
\label{sec:muut}

\subsection{Yleisiä vertailtavien ohjelmointikielten ominaisuuksia}

C:hen vertailtavissa ohjelmointikielissä on yleisesti useita ominaisuuksia,
jotka vaikuttavat ohjelmien suoritusaikaiseen nopeuteen hidastavasti, lisäävät
muistinkäyttöä tai vähentävät alustariippumattomuutta.

Yleisin näistä on automaattinen muistinhallinta, joka muistin vapauttamisen
automatisoimiseksi seuraa ohjelman käyttämää muistia. Lähes aina automaattinen
muistinhallinta lisää kieleen ''roskien keräämisen''\defword{garbage
collection, GC}, jonka ajaksi ohjelman suoritus pysäytetään. Lisäksi roskien
keräämiseen perustuva automaattinen muistinhallinta lisää muistinkäyttöä, sillä
ohjelmointikieli joutuu suoritusaikaisesti seuraamaan käytössä olevia
muistiosoitteita.

Monissa vertailtavissa kielissä on käytössä nimiruntelu\defword{name mangling},
joka mahdollistaa useat näennäisesti samannimiset funktiot. Tämä kuitenkin
aiheuttaa ohjelmointikielten välille yhteensopivuusongelmia, sillä toisesta
kielestä kutsuttaessa pitää tietää kutsuttavan funktion todellinen nimi.

Ohjelmointikielen ominaisuudet vaikuttavat siihen, minkälaisia
ohjelmistoarkkitehtuureja kielellä tehdään\citationneeded. Moderneissa
ohjelmointkielissä virheiden käsittely on yleensä toteutettu kahdella tavalla:
toinen on poikkeavat paluuarvot ja toinen on poikkeuksien heittäminen.
Yleisesti ottaen kaikki ohjelmointikielet tukevat ensimmäistä ja suurin osa
toista tapaa. Poikkeusten käsittely on hieman hitaampaa ja aiheuttaa hieman
suuremman muistinkäytön, ja tehokkaaseen ohjelmakoodiin pyrkiessä yleensä
vältetään poikkeusten käyttämistä\citationneeded. Monet poikkeuksia tukevien
ohjelmointikielten vakiokirjastot kuitenkin hallitsevat virhetilanteita
poikkeuksilla, mikä pakottaa ohjelmoijan käyttämään poikkeuksia ohjelmoidessa.

\hl{Tarkista kieli}

Ada on ainoa ohjelmointikieli, jossa ei ole mahdollisuutta käännösaikaisille
makroille. C ja C++ jakavat yksinkertaisen makrojärjestelmän, joka on
kuitenkin hyvin rajoittunut. Rustissa on kaksi erillistä makrojärjestelmää:
varsinaiset makrot, joiden lisäksi Rustista löytyy kokeellinen lisäosapohjainen
koodingenerointi. Go-kielessä taas on pelkästään lisäosapohjainen
koodigenerointi.

C:n ja C++:n makrot ajetaan ennen muuta koodin käsittelyä, eli makroja voi
sijoittaa mihin tahansa koodia. Rust ja Go taas käsittelevät makrot vasta
parsimisen jälkeen, eli ohjelman täytyy olla kielen mukaista ennen kuin makrot
suoritetaan -- makroilla ei voi käsitellä mitä tahansa tekstiä. Rust vaatii
erottimet, eli sulkeiden, lainausmerkkien ja heittomerkkien olevan kunnossa.
Lisäksi Rust-kääntäjän tulee tunnistaa kielen tekstialkiot~\defword{lexeme}
ennen makrojen suorittamista, eli Rust ei mahdollista uusien operaattoreiden
määrittämistä. Go ei salli yhtään alkuperäisestä kielestä poikkeamista ennen
makrojen ajamista. Go-kielen ja Rustin makroprosessorit ovat
turing-täydellisiä~\citep{rustmacros, gogenerate}\footnote{Rust ja Go
mahdollistavat koodin generoinnin suoraan Rustilla ja Go-kielellä erillisen
ohjelmointikielen sijaan. Rust ja Go ovat Turing-täydellisiä, eli näiden
kielien makroprosessorit ovat myös itsessään turing-täydellisiä.}, kun taas C:n
ja C++:n ei\footnote{C:n ja C++:n makrojärjestelmä ei ole edes
primitiivirekursiivinen, sillä makrot eivät voi sisältää itseään.}. 

Makrojärjestelmän hygieenisyydellä tarkoitetaan makrojen evaluoinnissa
tapahtuvien mahdollisten konfliktien ratkaisemiseen liittyviä ominaisuuksia.
Näitä konflikteja ovat esimerkiksi käytössä olevat muuttujien tunnisteet ja
ohjelmien rakenne~\citep{macrohygiene}. C ja C++ eivät sisällä hygieenistä
makroprosessoria, kun taas Go-kielen ja Rustin makroprosessorit ovat
hygieenisiä. Ohjelmassa~\ref{fig:cmacro} on esimerkki epähygieenisestä
makrosta. \texttt{DOUBLE}-makro muuttuu käännösvaiheessa muotoon $1+1*2$, joka
on laskujärjestyksen takia 3 eikä odotettu 4. Lopulliseksi printf-kutsuksi
muodostuu siis \texttt{printf("One plus one doubled is \%d", 1+1*2)}. Ongelman
voi kiertää tässä tapauksessa määrittelemällä \texttt{DOUBLE}-makron
\texttt{x*2} sijaan \texttt{((x)*2)}, jolloin sulut pakottavat
laskujärjestyksen oikein.

\FloatBarrier

\begin{listing}[ht!]
    \inputminted{C}{c-hygiene.c}
    \inputminted{text}{c-hygiene-output.txt}
    \caption{C:n ja C++:n makrot eivät ole hygieenisiä. DOUBLE-makro muuttuu
    käännösvaiheessa muotoon $1+1*2$, joka on laskujärjestyksen takia 3 eikä
    odotettu 4.}
    \label{fig:cmacro}
\end{listing}

\FloatBarrier

\subsection{Ada}

Ada on Yhdysvaltain puolustusministeriön kehittämä ohjelmointikieli, joka
suunniteltiin korvaamaan kaikki muut puolustusministeriön käyttämät
ohjelmointikielet~\citep{adahistory}, muun muassa C:n. Ada on hyvin moneen
taipuva kieli, sillä se on suunniteltu hallitsemaan monia eri
käyttötarkoituksia matalan tason bittitason ohjelmoinnista korkean tason
arkkitehtuureihin.

Ohjelmoinnin tehostamiseksi Adassa on sekä poikkeukset että automaattinen
muistinhallinta. Nämä kuitenkin hidastavat kieltä hieman aikaisemmin todetuistä
syistä. Lisäksi C-kielen kanssa yhteensopivuus on kielen taipuvuudesta johtuen
hankalaa -- jokainen kutsuttava C-funktio on yksitellen määritettävä
kutsukonvention\defword{calling convention} kanssa~\citep[s.~471]{ADA12}. Adan
alustariippumaton C-tuki on kuitenkin äärimmäisen kattava, paikoitellen C:n
omaa tukea kattavampi (C:n standardi ei kuvaile esimerkiksi kutsukonventioita,
vaan ne on jätetty kään\-tä\-jä\-spesifeiksi asetuksiksi). Ada on myös
vertailuin ainoa kieli, joka voi kutsua muilla ohjelmointikielillä
kirjoitettuja kirjastorutiineja suoraan ilman C-rajapintojen käyttöä. Adassa on
C:n lisäksi tuki C++:lle\footnote{C++-tuki ei sisällä nimiruntelun tukemista,
vaan kutsuttavista funktioista pitää määrittää runnellut nimet.}, Fortranille
ja Cobolille~\citep[s.~585]{ADA12}.

\subsection{C++}

C++ on Bjarne Stroustrupin 1980-luvusta eteenpäin kehittämä kieli, jonka
yhtenä tarkoituksena on yhdistää Simula-kielen ominaisuudet ohjelman
organisointiin yhteen C:n tehokkuuden ja joustavuuden
kanssa~\citep{cpphistory}. C++ on nykypäivänä suosittu tehokkuutensa ja
monipuolisuutensa takia monimutkaisissa ohjelmistoissa, kuten
palvelinohjelmistoissa, kuvankäsittelyohjelmistoissa sekä
peleissä~\citep{cppapps}.

C++ on kehitetty C:n pohjalta, ja siinä onkin erittäin hyvä C-tuki. Koska
C++\hyp{}funktiot nimirunnellaan eikä nimiruntelua ole määritelty tarkasti C++:n
standardissa, C++-koodia on hankalaa kutsua jopa samalla alustalla eri
C++-kääntäjien välillä. C-koodin otsikkotiedostoissa\defword{header file} on
usein alussa C++-koodia, joka laittaa nimiruntelun pois päältä. Näin
C++-ohjelmat voivat helposti kutsua C:llä kirjoitettujen kirjastojen funktioita
-- C++-ohjelmat voivat usein käyttää C-kielen otsikkotiedostoja ilman muita
muokkauksia.

C++:n standardikirjaston virheidenkäsittely on toteutettu poikkeuksilla, jotka
aiheuttavat pienen hidastuksen. C++:ssa on myös käytettävissä
viitemäärälaskettu\defword{reference counting} muistinhallinta (vakiokirjaston
\texttt{std::shared\_ptr}), jolla voidaan käyttää suoritusaikaisesti varattua
muistia ilman muistivuotoja. C++:n \texttt{std::shared\_ptr} ei käytä erillistä
roskien keräystä, vaan kun viimeinen viite olioon poistetaan, myös varattu
muisti vapautetaan. Tällöin ohjelman suorituksen aikana ei tule
roskienkeräystaukoja.

C++ tukee geneeristä ohjelmointia\defword{generic programming} luokkien
yhteydessä malliohjelmoinnilla\defword{template programming}. C++:n
toteutuksessa jokaisesta uniikista mallin tyyppiparametrikombinaatiosta luodaan
lopulliseen ohjelmaan kopio mallin funktioista, joka kasvattaa ohjelmien kokoa.
Tämä mahdollistaa jokaisen luokan ilmentymän\defword{instance} erillisen
optimoinnin, mutta yleisesti kasvattaa sekä kääntämisaikoja että ohjelmien
kokoa.

\subsection{D}

D on 2000-luvun alussa Digital Mars -yrityksen julkaisema ohjelmointikieli,
jonka tarkoituksena on mahdollistaa tehokkaan ohjelmakoodin kirjoittaminen
helposti ja turvallisesti~\citep{dhistory}. D on suunniteltu syntaksiltaan ja
käytökseltään lähelle C:tä ja C++:aa. Vaikka D-kielessä on olemassa
automaattinen muistinhallinta, D:n \emph{BetterC}-tila tekee kielestä
''paremman C:n'' poistamalla suoritusaikaiset ominaisuudet, mukaan lukien
automaattisen muistinhallinnan~\citep{dbetterc}. Tällöin kielestä poistuu
useita ominaisuuksia, mutta esimerkiksi D:n käännösaikaista makrojärjestelmää
voi käyttää.

C-koodin kutsuminen on melko helppoa, mutta ei aivan saumatonta, sillä jokainen
kutsuttava funktio tulee määritellä erikseen -- D ei ymmärrä C:n
otsikkotiedostoja. Tämä kuitenkin onnistuu yhdellä rivillä jokaista C:n
funktiota kohden, sillä D:n tyyppijärjestelmä on hyvin lähellä C:tä. D:lle on
myös olemassa useita työkaluja otsikkotiedostojen automaattiseen muuntamiseen,
kuten \texttt{htod}-työkalu~\citep{htod}. Työkalut eivät kuitenkaan ole
täydellisiä, sillä useiden D:n ominaisuuksien semantiikka ei ole C:n kanssa
yhteensopiva.

\subsection{Go}

Go on Googlen 2000-luvun loppupuolella kehittämä ohjelmointikieli, jonka
tarkoituksena on yhdistää käännösaikaisesti tyypitetyn ohjelmointikielen
turvallisuus ja tehokkuus suoritusaikaisesti tyypitettyjen ohjelmointikielten
helppokäyttöisyyteen~\citep{gohistory}. Toisin kuin monissa moderneissa
C-perheen kielissä, Go-kielessä ei ole luokkia, vaan pelkkiä tietueita ja
rajapintoja. Go suunniteltiin erityisesti korvaamaan C++:n käyttö Googlella
johtuen C++:n pitkistä käännösajoista.

Go-kielessä ei ole muista vertailtavista kielistä poiketen tyyppiparametreja.
Tämä estää käännösaikaisesti tyyppitarkistetun geneerisen koodin
kirjoittamisen. Ohjelmat voivat kuitenkin suoritusaikaisesti reflektion kautta
tunnistaa muuttujien konkreettisen tyypin. Tämän mahdollistaminen kasvattaa
ohjelmakoodin kokoa, sillä rajapinnan mukana on säilytettävä rajapinnan oikeaa
tyyppiä. Tämä kuitenkin yksinkertaistaa ohjelmien kirjoittamista, sillä
ohjelmoijan ei tarvitse miettiä kirjoittamishetkellä monimutkaisia
tyyppejä~\citep[esim.][kalvo 8]{gohistory}, kuitenkin mahdollistaen geneerisen
koodin kirjoittamisen. Ohjelmassa~\ref{fig:goreflection} käsitellään
value-muuttujaa geneerisesti - jos muuttuja on tyyppiä \texttt{string},
muuttuja palautetaan sellaisenaan. Jos muuttujassa toteuttaa
\texttt{Stringer}-rajapinnan, eli siinä on \texttt{String()}-metodi, sitä
kutsutaan ja palautetaan tulos. Muussa tapauksessa palautetaan tyhjä
merkkijono.


\begin{listing}[ht!]
    \inputminted{go}{goreflect.go}
    \caption{Geneerinen funktio Go-kielessä. Jos \texttt{value}-muuttuja on
    tyyppiä \texttt{string}, muuttuja palautetaan sellaisenaan. Jos muuttujassa
    toteuttaa \texttt{Stringer}-rajapinnan, eli siinä on
    \texttt{String()}-metodi, sitä kutsutaan ja palautetaan tulos. Muussa
    tapauksessa palautetaan tyhjä merkkijono.}
    \label{fig:goreflection}
\end{listing}


Go-kielen virheidenkäsittely on toteutettu useissa kohdissa C:n tavoin;
funktioista palautetaan virheellisissä tilanteissa virheellinen arvo. Tämä
tosin tehdään usein palauttamalla erillinen \texttt{Error}-tyyppiä oleva arvo
-- Go mahdollistaa useamman kuin yhden paluuarvon. Go-kielessä on myös
poikkeukset, joita suositellaan käytettävän vain poikkeuksellisissa
tilanteissa~\citep{effectivego}.

C:n kutsuminen Go-kielestä ei ole aukotonta: koska Go on muistinkäytöltä
turvallinen kieli, erityisesti muistin jakaminen C:n ja Go-kielen välillä on
hankalaa. Lisäksi C:n funktio-osoittimia ei voi kutsua Go-kielen
puolelta~\citep{cgo}. Go mahdollistaa C-otsikkotiedostojen suoran käytön
ohjelmakoodista, mikä helpottaa C-koodin kutsumista.

\subsection{Rust}

Rust on Mozilla Foundationin kehittämä ohjelmointikieli, joka on suunniteltu
turvalliseksi, rinnakkaiseksi ja käytännölliseksi
järjestelmäohjelmointikieleksi~\citep{rustfaq}. Rustissa on monimutkainen
tyyppijärjestelmä, jolla ohjelmat voivat todistaa esimerkiksi turvallisen
rinnakkaisajon ilman, että ohjelmaan tulee suoritusaikaisia rajoitteita tai
hidastuksia. Rust alkoi Graydon Hoaren henkilökohtaisena sivuprojektina, mutta
on nyt käytössä osana Gecko-selainmoottorin kehitystä C++:n ja JavaScriptin
ohella.

Kuten Go-kielessä, Rustissa voi myös käyttää poikkeuksia. Rustin
virheidenhallinta on muutenkin lähellä Go-kielen virhehallintaa -- Rustin
ohjekirja opastaa käyttämään mieluummin paluuarvoja kuin
poikkeuksia~\citep{rusterrorhandling}.

Rustin monimutkainen tyyppijärjestelmä kannustaa kirjoittamaan turvallisia
ohjelmia, Tietorakenteiden mutatoiminen on tehty tietoisesti hankalaksi, sillä
monimutkaisissa ohjelmissa holtittomasti muuttuva tila on usean vian syynä, ja
muuttumaton tila tekee monisäikeistettyjen\defword{multithreaded} ohjelmien
toteutuksesta huomattavasti helpompaa\citationneeded. Kullakin muuttujalla voi
olla joko rajaton määrä muuttumattomia viitteitä\defword{immutable reference}
tai yksi muuttuva viite\defword{mutable reference}, mutta molempia ei voi
käyttää yhtä aikaa.

Turvallisuudella on kuitenkin hintansa -- Rust-ohjelmat vievät enemmän tilaa
kuin vastaavat C-ohjelmat. Jos Rust-ohjelmista poistaa standardikirjaston ja
käyttää suoraan C:n standardikirjastoa, ohjelmasta saa miltei samankokoisen
kuin vastaavasta C-kielellä kirjoitetusta ohjelmasta~\citep{rustbinarysize}.
Samalla tosin suurin osa Rustin ominaisuuksista jää pois. Rustin turvallisuus
vaatii myös monimutkaisen tyyppijärjestelmän, joka on vaikeampi opetella kuin
yksinkertaisemman kielen tyyppijärjestelmä.

Rust ei pysty suoraan käsittelemään C:n otsikkotiedostoja, mutta D:n tavoin
Rustille on saatavilla työkaluja otsikkotiedostojen automaattiseen
muuntamiseen~\citep{rustbindgen}. Rust kuitenkin suosittelee jokaisen kirjaston
kohdalla käsin ympäröimään C-kirjaston funktiot, sillä C:n tyyppimäärittelyt
eivät tarjoa Rustin vaatimaa tarkkuutta funktioiden turvallisuudesta.

\newpage

\subsection{Yhteenveto}

Yksikään vertailtavista kielistä ei täytä kaikkia luvussa~\ref{sec:abs}
määriteltyjä rajoitteita. Yksikään kielistä ei täytä muistinkäytön rajoitteita,
jonka lisäksi saumaton yhteistyö C:n kanssa onnistuu vain C++:n kanssa. C++, D
ja Rust mahdollistavat nimiruntelun poistamisen käytöstä, mutta tämä ei toimi
esimerkiksi C++:n luokkien yhteydessä. Ada mahdollistaa funktioiden nimien
muuttamisen linkkeriä varten, jolloin esimerkiksi
\texttt{EsimerkkiFunktio}-nimistä funktiota voidaan kutsua
\texttt{esimFunk}-nimellä. Kaikki vertailtavat kielet tukevat
vierasfunktiorajapintoja C:n mukaisesti, eli kielet voivat kutsua muita kieliä
C-rajapintojen läpi. C++ ja Rust ovat hyvin lähellä C:tä käännettyjen ohjelmien
koossa, mutta häviävät C:lle laajojen vakiokirjastojen takia. Molemmat ovat
myös hyvin monimutkaisia kieliä. Vain C++ ja Go voivat sisällyttää ohjelmiin
C:n otsikkotiedostoja, kun taas Ada, D ja Rust vaativat jokaisen funktion
määrittämistä. Adalle, D:lle ja Rustille on tosin olemassa työkaluja, joilla
tämän määrittämisen voi automatisoida.

\begin{table}[ht!]
    \begin{adjustbox}{center}
    \begin{tabular}{@{}lllll@{}} \toprule
        Kieli & Nimiruntelu   & Muistinhallinta                                     & C:n VFR               & muiden kielten VFR \\ \midrule
        Ada   & täysin hallittavissa & automaattinen                                       & Työläs mutta kattava  & C, C++, Fortran, Cobol \\
        C++   & saa pois päältä            & manuaalinen                                         & Lähes saumaton        & C:n läpi \\
        D     & saa pois päältä            & molemmat                                            & Työläs mutta kattava  & C:n läpi \\
        Go    & on            & automaattinen                                       & Epätäydellinen        & C:n läpi \\
        Rust  & saa pois päältä & automaattinen\footnote{Borrow Checkerin hallitsemana, joka mahdollistaa automaattisen muistinhallinnan ilman sen aiheuttamaa hidastusta.} & Työläs mutta kattava  & C:n läpi \\ \bottomrule
    \end{tabular}
    \end{adjustbox}
    \caption{
        Kielten ominaisuuksien yhteenveto.
    }
    \label{table:properties}
\end{table}

\hl{Tänne lisää tekstiä.}

\FloatBarrier

\newpage

Benchmarks gamen tulokset myös heijastavat näitä tuloksia -- C++ ja Rust ovat
nopeudeltaan hyvin lähellä C:tä, kun taas Ada ja Go ovat huomattavasti
hitaampia.

\FloatBarrier

\begin{figure}[ht!]
    \begin{adjustbox}{center}
    \begin{minipage}{1.1\textwidth}
    \begin{minipage}{0.5\textwidth}
        \input{benchmarks/benchmarkscpu.tex}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \input{benchmarks/benchmarksmem.tex}
    \end{minipage}
    \end{minipage}
    \end{adjustbox}
    \caption{
        Benchmarks gamen~\citep[data haettu 29.11.2018]{benchmarks} dataan
        perustuvat kuvaajat ohjelmointikielten suorituskyvystä ja
        muistinkäytöstä.
    }
    \label{fig:benchmarksgame}
\end{figure}

\FloatBarrier

Kuvassa~\ref{fig:benchmarksgame} verrataan kielien suorituskykyä ja
muistinkäyttöä. C, C++ ja Rust ovat hyvin lähellä toisiaan sekä muistinkäytössä
että suoritusnopeudessa. Ada ja Go ovat selkeästi hitaampia, ja käyttävät
enemmän muistia. C++ on yksittäisissä suorituskykytesteissä C:tä nopeampi. Rust
sijoittuu muistinkäytössään C:n ja C++:n väliin.

\hl{Tänne lisää tekstiä.}
