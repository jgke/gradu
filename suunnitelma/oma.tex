\section{Uudelta kieleltä vaadittavat ominaisuudet}

\subsection{Ominaisuuksia}

Uuden ohjelmointikielen tulee olla mahdollisimman yhteensopiva C:n kanssa. Tämä
onnistuu parhaiten pitämällä ajoaikaisten ominaisuuksien määrän mahdollisimman
pienenä. Muistinhallinnan tulee olla manuaalinen, jotta kutsuessa C-funktioita
kielet voivat saumattomasti ja tehokkaasti jakaa osoitinmuuttujia. Moniajoa ei
voi alustariippumattomuuden takia tukea suoraan standardikirjastossa, mutta
spesifikaatio voi ehdottaa yhteistä rajapintaa moniajototeutuksille.

Jotta kieltä voi käyttää nykyisissä ympäristöissä, sen tulee kääntyä C:ksi.
Tällöin ohjelmointikieli toimii kaikissa ympäristöissä, joihin on olemassa
C-standardin mukainen C-kääntäjä. Tämä mahdollistaa integroinnin nykyisten
työkalujen kanssa -- esimerkiksi \texttt{Make}-työkalulla~\citationneeded uuden
kielen tiedostot voi kääntää kahdella rivillä rivillä:

\inputminted{make}{Makefile.kieli}

Tämän jälkeen olemassaolevat .c-tiedostot voi poistaa, ja \texttt{Make} osaa
luoda ne .kieli-tiedostojen pohjalta. Kääntäjän tulee tuottaa ylläpitokelpoisia
.c-tiedostoja, jotta kielestä voi myös tarvittaessa siirtyä pois helposti.
Kielen tulee myös tukea C:n otsikkotiedostoja, jotta ohjelmoijilta ei mene
turhaan aikaa funktiomäärittelyiden kääntämiseen kieleltä toiselle. Vastaavasti
kielen tulee myös tarvittaessa tuottaa C-kielen otsikkotiedostoja -- näin voi
helposti uudelleenkirjoittaa C-kirjastoja.

\hl{Ohjelmointikielen nimi yms. työn alla}

Ajoaikaisen tyyppijärjestelmän tulee olla täysin yhteensopiva C:n kanssa.
Esimerkki tällaisesta kielestä on TypeScript~\citationneeded, joka lisää vahvan
tyypityksen JavaScriptiin kuitenkin vaikuttamatta mitenkään ajoaikaisiin
ominaisuuksiin. Myös Rustin ajoaikainen tyypitys on lähellä C:tä; Rustin
\texttt{Box<T>} vaatii, että tyyppiparametrin arvo ei ole tyhjä~\footnote{NULL
-- onko tähän parempia käännöksiä?}, jolloin laatikossa voi säilyttää C:n
tavoin esimerkiksi merkkijonoja -- tyhjä arvo vastaa C:n NULLia.

Tyhjiä arvoja on kuvailtu ``Miljoonan dollarin virheeksi'' niiden keksijän
toimesta~\citep{billiondollars}. Useat ohjelmointikielet ovatkin poistaneet
muuttujilta mahdollisuuden olla tyhjiä arvoja, kuitenkin mahdollistaen tyhjät
arvot esimerkiksi yhdellä merkillä lisää tyyppimäärittelyssä. Jos uuteen
kieleen otetaan tällainen oletus, C-funktiomäärittelyiden tulee saumattoman
yhteistyön takia olla ``limbossa'' näiden kahden tilan välillä, sillä C:n
syntaksi ei sisällä lupauksia mahdollisista tyhjistä arvoista -- tai niiden
puutteesta. Ohjelmoijaa siis ei voi pakottaa tarkistamaan tyhjiä arvoja, jos
hän kutsuu jotain C-funktiota, mutta toisaalta ei myöskään varoittaa 'turhista'
tarkistuksista.

Koska kieli voi vaikuttaa lähinnä käännösaikaisesti, tulee kielen
makrojärjestelmän olla sekä turvallinen että voimakas. Rustin makrojärjestelmä
on vahvasti tyypitetty sekä Turing-täydellinen~\citep{rustmacros}. Tämä
mahdollistaa myös monimutkaisten makrojen kirjoittamisen ja käytön. Rustin
makrosyntaksi on kuitenkin ensisilmäyksellä vaikeaselkoista, kun taas C:n
makrot ovat pitkälti helppolukuisia.

C-kääntäjissä on aina alustariippuvaisia ominaisuuksia, ja yksi tärkeimmistä on
funktioiden kutsuminen. GCC:n~\citationneeded kanssa yhteensopivat kääntäjät
tukevat funktiomäärittelyn kohdalla \texttt{\_\_attribute\_\_()} -määrettä,
joka kertoo, miten funktiolle tulisi antaa ajoaikaisesti parametrit.

C++:n yksi tärkeistä ominaisuuksista on nimiavaruudet, joita C:ssä ei ole. Jos
samassa ohjelmassa on kaksi samannimistä funktiota, ei ole määritelty, kumpaa
niistä kutsutaan. C++:ssa ongelma on ratkaistu nimiruntelulla. Tämä on
kuitenkin aiheuttanut ristiriitoja sekä C-yhteensopivuuden kanssa että eri
C++-kääntäjien yhteensopivuuden kanssa.

\subsection{Syntaksi}

Jotta kielestä toiseen vaihtaminen olisi kannattavaa, uuden kielen on oltava
tarpeeksi erilainen: samanlainen kieli ei tarjoa tarpeeksi parannusta
olemassaolevaan, että siirtyminen olisi kannattavaa. C:n syntaksia on usein
kritisoitu\citationneeded vuolaudesta, joten syntaksia typistämällä voisi saada
huomattavia parannuksia.

\begin{figure}[ht!]
    \inputminted{C}{strcmp.c}
    \inputminted{Haskell}{strcmp.hs}
    \caption{C:n \texttt{strcmp}-funktio toteutettuna C:llä ja Haskellilla,
    jota voi käyttää merkkijonojen vertailuun. Ylempi on C-kieltä, kun taas
    alempi esimerkki on kirjoitettu Haskellilla.
    \hl{Käyn näitä tarkemmin läpi myöhemmin}
    \label{fig:strcmp}
}
\end{figure}

\FloatBarrier

Jotta kieli on mahdollisimman kevyt ja alustariippumaton, kielen
standardikirjaston tulee olla mahdollisimman kevyt. Kielen makrojärjestelmän
tulee olla tarpeeksi voimakas, että alustariippuvaiset ominaisuudet voidaan
toteuttaa puhtaasti kirjastotasolla.

C:n tyyppisyntaksia on usein~\citationneeded kritisoitu. vaikka kielessä onkin
sinänsnä järkevä logiikka tyyppimäärittelyyn: jos tyyppimäärittely on esimerkiksi
\texttt{int (*fp)(int arg, char arg2)}, kirjoittamalla koodiin
\texttt{(*fp)(int, char)} saa arvon tyyppiä \texttt{int}. Monimutkaisissa
tapauksissa on vaikeaa seurata tyypin oikeaa arvoa, ja monet ohjelmointikielet
ovatkin kehittäneet vaihtoehtoisia tapoja merkitä tyyppejä. Modernimpi tapa
ilmaista yllä oleva tyyppi on \texttt{fp: (int, char) -> int}.

Yksi hyvin suosituista ominaisuuksista moderneissa ohjelmointikielissä on
tyyppi-inferenssi. Oikein käytettynä sillä voidaan poistaa lähdekoodista
pääteltävissä olevat tyypit, jolloin ohjelmoija voi keskittyä ohjelmalogiikkaan.
Tyyppi-inferenssi onkin erityisen kätevä lambdojen kirjoittamisessa, sillä
ohjelmoijan ei tarvitse kirjoittaa täysin pääteltäviä tyyppejä.

Toinen suosittu ominaisuus on hahmontunnistus\footnote{eng. pattern matching},
jolla voidaan kasvattaa kielen ilmaisuvoimaa. Kuvassa~\ref{fig:strcmp}
Haskell-esimerkki käyttää hahmontunnistusta oikean funktion valitsemiseen.

Gon yksi innovatiivisimmista ominaisuuksista on \texttt{defer}, jolla voidaan
viivästyttää laskentaa funktiosta poistumiseen asti. Esimerkiksi \emph{A Tour
of Go} -sivuston esimerkissä~\citep{gotourdefer} käytetään \texttt{defer}iä
Hello World -ohjelman toteuttamiseen:

\begin{figure}[ht!]
    \inputminted{Go}{defer.go}
    \inputminted{text}{defer-output}
    \caption{\texttt{defer}-avainsana siirtää world-sanan tulostamisen funktion
    loppuun, jolloin ohjelma tulostaa sanat ``hello'' ja ``world''.}
\end{figure}

\FloatBarrier

Ilman automaattista muistinhallintaa kaikissa tilanteissa toimivaa
\texttt{defer}iä ei voi toteuttaa, mutta yksinkertaisissa tilanteissa myös
hyvin matalan tason kieli voisi toteuttaa \texttt{defer}-avainsanan.
Avainsanalle tulisi käyttöä -- esimerkiksi Linux-kernelissä on yleinen kuvio
vapauttaa kaikki funktion varaama muisti käänteisessä järjestyksessä
virhetilanteissa. Vain virhetilanteissa ajettu \texttt{defer} mahdollistaisi
huomattavaa siivoamista -- ohjelmoijan ei tarvitse ajatella muistin
vapauttamista, sillä ohjelmointikieli tekee sen ohjelmoijan puolesta.

Vielä monimutkaisempi tapaus on sulkeumat, joita suositaan erityisesti
funktionaalisen ohjelmoinnin yhteydessä. GCC-kääntäjä on toteuttanut sulkeumat
C-kielelle käyttämällä Thomas Breuelin esittelemää
trampoliinimenetelmää~\citep{gccnested, cppclosure}.

\subsection{Toolaus}

Modernissa ohjelmointikielessä on tärkeänä osana kehittäjän hyvinvointi, jota
voidaan ylläpitää hyvillä työkaluilla. Go-kieli kehitettiin yhdessä kattavan
työkalupaketin kanssa, jolloin työkalut pysyivät mukana kielen kehityksessä.
Gon mukana tuleekin nykyään kääntäjän (\texttt{go build}) yhteydessä mm.
paketinhallinta \texttt{go get}, koodin automaattinen muotoilija \texttt{go
fmt} sekä ohjelmointivirheiden tarkastaja \texttt{go vet}. 

Kirjoittamalla kääntäjän ensin C:llä ja vasta myöhemmin hiljalleen siirtymällä
uuteen kieleen voidaan esitellä kielen mahdollisuutta toimia C:n korvaajana.
