\appendixsection{Liitteen nimi tähän}
\appendixlabel{app:purkka}

\counterwithout{listing}{section}

\begin{listing}[ht!]
    \inputminted{Rust}{koodi/sumtype.prk}
    \inputminted{Rust}{koodi/sumtype.c}
    \caption{Summatyyppi Purkka-kielessä ja sama summatyyppi käännettynä C-kielelle.}
    \label{fig:purkkatreecompile}
\end{listing}

\begin{listing}[ht!]
    \inputminted{Rust}{koodi/sumtype2.c}
    \caption{Ohjelman~\ref{fig:purkkatreecompile} optimoitu C-versio.}
    \label{fig:purkkatreecompile2}
\end{listing}

%\makeatletter
%\show\@startsection
%\makeatother
%{subsection}{2}{\z@ }{-3.25ex\@plus -1ex \@minus -.2ex}{1.5ex \@plus .2ex}{\normalfont \large \bfseries }.

\renewcommand{\subsection}[1]{\vspace{1.7ex}{\large\textbf{#1}\vspace{1.7ex}}}

\subsection{Alkeistyypit}

Taulukko ei sisällä keskenään identtisiä C-tyyppejä, kuten \texttt{int} ja
\texttt{signed int}. \\[0.3cm]
\begin{tabular}{@{}p{5.8cm}p{8.7cm}@{}} \toprule
    Purkka-tyyppi & Purkka-tyyppiä vastaava C-tyyppi \\ \midrule
    \texttt{void} & \texttt{void} \\
    \texttt{char} & \texttt{char} \\
    \texttt{i8}, \texttt{i16}, \texttt{i32}, \texttt{i64} &
    \texttt{int8\_t}, \texttt{int16\_t}, \texttt{int32\_t}, \texttt{int64\_t} \\
    \texttt{u8}, \texttt{u16}, \texttt{u32}, \texttt{u64} &
    \texttt{uint8\_t}, \texttt{uint16\_t}, \texttt{uint32\_t}, \texttt{uint64\_t} \\
    \texttt{float} & \texttt{float} \\
    \texttt{double} & \texttt{double} \\
    [0.3cm]

    \texttt{cbyte}, \texttt{cshort}, \texttt{cint}, \texttt{clong}, \texttt{clonglong}
    & \texttt{signed char}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{long long} \\
    \noalign{\vspace{0.3cm}}

    \texttt{cubyte}, \texttt{cushort}, \texttt{cuint}, \texttt{culong}, \texttt{culonglong}
    & \texttt{unsigned char}, \texttt{unsigned short}, \texttt{unsigned int},
      \texttt{unsigned long}, \texttt{unsigned long long} \\
    \bottomrule
\end{tabular} \\

\subsection{Osoitintyypit, taulukkotyypit sekä yhdistetyypit}

\begin{tabular}{@{}ll@{}} \toprule
    Purkka-tyyppi & Purkka-tyyppiä vastaava C-tyyppi \\ \midrule
    \texttt{\&T, \&?T} & \texttt{T *} \\
    [0.2cm]

    \texttt{[T]} & \texttt{T\textsubscript{declaration specifiers}[]T\textsubscript{direct abstract declarator}} \\
    \texttt{[T;expr]} & \texttt{T\textsubscript{declaration specifiers}[expr]T\textsubscript{direct abstract declarator}} \\
    [0.2cm]

    \texttt{fun t: (T ..) -> R} & \texttt{R\textsubscript{declaration specifiers}~t(T ..)R\textsubscript{direct abstract declarator}} \\
    \texttt{fun (T ..) -> R} & \texttt{R\textsubscript{declaration specifiers}~(*)(T ..)R\textsubscript{direct abstract declarator}} \\
    [0.2cm]

    \texttt{struct \{ k: T ..\}} & \texttt{struct \{ T k ..\}} \\
    \texttt{enum \{ A [= expr] ..\}} & \texttt{enum \{ A [= expr] ..\}} \\
    \texttt{union \{ k: T ..\}} & \texttt{union \{ T k ..\}} \\
    [0.2cm]

    \texttt{(T1 ..)} & \texttt{struct \{ T1 e1; ..\}} \\
    \texttt{enum \{ T(T1 ..) .. \}} & \texttt{struct \{ union \{T1 t1 ..\} v; enum \{T ..\} e;\}} \\
    [0.2cm]

    GCC-laajennokset & \\
    \texttt{attribute(T, ...))} & \texttt{T \_\_attribute\_\_((...))} \\

    \bottomrule
\end{tabular} \\

Koska kieli ei voi erota C:stä suoritusaikaisesti, tyypitys on hyvin lähellä
C:n tyypitystä.

Tyypit:
 C + tagged union + non-nullable pointer

kuinka tagged union käännetään C:ksi? Entä non-nullable ptr?

tyyppipäättely

Mitä optimointeja non-null tarjoaa? Entä tagged union?

\subsection{Tyyppipäättely}

Purkka käyttää tyyppipäättely toteuttamisen pohjana yleisesti käytettyä
Damas-Hindley-Milner -algoritmia~\citep{hindley, milner, damas}.

Jotta päättelyalgoritmi toimisi lineaariaikaisesti suhteessa syötteen kokoon,
osassa lausekkeista muuttujien tyyppien tulee olla tiedossa sillä hetkellä, kun
lausekkeen tyyppiä selvitetään. Yhteen- ja vähennyslasku voi vaatia myös
tyyppimäärittelyt, jos yhteenlaskettavat parametrit ovat osoittimia\footnote{C
sallii osoitinmuuttujan ja kokonaisluvun yhteen- ja vähennyslaskun sekä kahden
osoittimen vähennyslaskun.}. Näistä selkein esimerkki on struct-tyyppien kentän
käyttäminen, jonka tyyppiä kääntäjä ei suostu päättelemään, jos muuttujan
tyyppi ei ole tiedossa. Koodissa~\ref{fig:structinfer} on kaksi esimerkkiä
tyyppipäättelystä struct-muuttujiin: ensimmäisessä esimerkissä
tyyppipäättely onnistuu, mutta toisessa ei.

\begin{listing}[ht!]
    \inputminted{Rust}{koodi/infer.prk}
    \caption{Esimerkki tyyppipäättelystä.}
    \label{fig:structinfer}
\end{listing}



\FloatBarrier

\hl {Esimerkissä kysymysmerkkejä. Selitys auki}

\hl{Tämä vaatii \textbf{paljon} lisää avaamista, selittämistä ym. tekstiä.
Lisäksi pitää vahvistaa, että Purkka-kääntäjä oikeasti toimii näiden
perusteella, eikä \emph{melkein} identtisten päättelysääntöjen avulla.}

\newcommand{\hmtag}[1]{\tag*{[#1]\hspace*{1cm}}}

\begin{gather}
    \frac
      {x: \sigma \in \Gamma}
      {\Gamma \vdash _{D}x:\sigma} \hmtag{Var} \\
    \intertext{Var on yksinkertaisin päättelysääntö: jos ympäristössä $\Gamma$ on
    muuttuja $x$ tyyppiä $\sigma$, niin lausekkeissa muuttujan $x$ tyyppi on
    $\sigma$.}
%
    \frac
      {\Gamma \vdash _{D}e_{0}:\tau \rightarrow \tau '\quad \quad \Gamma \vdash _{D}e_{1}:\tau }
      {\Gamma \vdash _{D}e_{0}\ e_{1}:\tau '} \hmtag{App} \\
    \intertext{App tunnetaan paremmin funktiokutsuna. Jos $e_0$ on funktio,
    joka ottaa argumenteikseen arvot tyyppiä $\tau$ ja palauttaa arvon tyyppiä
    $\tau'$, ja $e_1$ on jokin arvo tyyppiä $\tau$, niin funktio $e_0$
    kutsuttuna $e_1$:llä palauttaa arvon tyyppiä $\tau'$.}
%
    \frac
      {\Gamma ,\;x:\tau \vdash _{D}e:\tau '}
      {\Gamma \vdash _{D}\lambda \ x\ .\ e:\tau \rightarrow \tau '} \hmtag{Abs}
    \intertext{Abs on yleisemmin tunnettu funktion määrittelynä. Jos
    olettamalla, että $x$:n tyyppi on $\tau$, voidaan päätellä että $e$:n tyyppi
    on $\tau'$, niin $\lambda x . e$ on funktio, joka ottaa argumenteikseen
    arvon tyyppiä $\tau$ ja palauttaa arvon tyyppiä $\tau'$.}
%
    \frac
      {\Gamma \vdash _{D}e_{0}:\sigma \quad \quad \Gamma ,\,x:\sigma \vdash _{D}e_{1}:\tau }
      {\Gamma \vdash _{D}{\mathrm {let}}\ x=e_{0}\ {\mathrm {in}}\ e_{1}:\tau } \hmtag{Let} \\
    \intertext{Let mahdollistaa uuden muuttujan luomisen. Toisin sanoen, jos
    luodaan muuttuja $x$, sitä voidaan käyttää myöhemmin.
    \newline \newline
    Jos voidaan päätellä, että $e_0$:n tyyppi on $\tau$ sekä olettamalla, että
    $x$:n tyyppi on $\sigma$ voidaan päätellä, että $e_1$:n tyyppi on $\tau'$,
    niin kaikki $e_1$:n sisältämät $x$:t voi korvata $e_0$:lla ja saada
    tulokseksi arvon tyyppiä $\tau'$.}
%
    \frac
      {\Gamma \vdash _{D}e:\sigma '\quad \sigma '\sqsubseteq \sigma }
      {\Gamma \vdash _{D}e:\sigma } \hmtag{Inst} \\
    \intertext{Inst mahdollistaa arvojen asettamisen myös hieman toisenlaisiin
    tyyppeihin, kuten vaikka \texttt{i8}-tyyppisen arvon asettamisen
    \texttt{i16}-tyyppiseen arvoon. Huomioitavaa on, että \texttt{i8}-osoitin
    ei ole yhteensopiva \texttt{i16}-osoittimen kanssa.
    \newline \newline
    Jos voidaan päätellä, että $e$ on tyyppiä $\sigma'$ ja $\sigma'$ on
    $\sigma$:n alityyppi, niin voidaan päätellä, että $e$ on tyyppiä $\sigma$.}
%
    \frac
      {\Gamma \vdash _{D}e:\sigma \quad \alpha \notin {\text{free}}(\Gamma )}
      {\Gamma \vdash _{D}e:\forall \ \alpha \ .\ \sigma } \hmtag{Gen} \\
    \intertext{Jos voidaan päätellä, että $e$ on tyyppiä $\sigma$ ja $\alpha$
    ei ole nykyisessä kontekstissa vapaa tyyppi, niin $e$ on tyyppiä $\sigma$
    kaikille $\alpha$:n tyypeille.} \notag
\end{gather}

\subsection{Syntaksi}

\hl{Tähän osioon voisi tehdä enemmän esimerkkejä.}

Purkan syntaksi on hyvin samankaltainen C:n syntaksiin verrattuna. Suurimmat
erot C:hen liittyvät tyyppien kirjoittamiseen.

Funktiomäärittelyt alkavat \texttt{fun}-avainsanalla. Tämä noudattaa usean muun
modernin ohjelmointikielen tapaa aloittaa funktiomäärittely avainsanalla.
Vertailun vuoksi Rust käyttää avainsanaa \texttt{fn}, Go käyttää avainsanaa
\texttt{func} ja Kotlin käyttää avainsanaa \texttt{fun}). Avainsanan
käyttäminen yksinkertaistaa jäsentäjän toteutusta.

Purkka tukee tyyppipäättelyä, joka helpottaa koodin kirjoittamista, kun
kääntäjä pystyy päättelemään muuttujien tyypit. Tyyppisyntaksi itsessään
muistuttaa paljon Rustin tyyppisyntaksia.

\hl{tukee tyyppipäättelyä alleviivattu}

C:n \texttt{static}-avainsana on jaettu käytön mukaisesti kahteen avainsanaan.
Funktiomäärittelyissä ja globaaleissa muuttujissa C:n
\texttt{static}-avainsanaa vastaa Purkan \texttt{pub}-avainsana (''public'' eli
julkinen), mutta käänteisellä merkityksellä: jos \texttt{pub}-avainsanaa ei ole
käytetty, koodi käyttäytyy kuin siihen olisi lisätty C:n
\texttt{static}-avainsana. Funktioiden sisällä Purkka tukee myös
\texttt{static}-avainsanaa, joka toimii samalla tavalla kuin C:n
\texttt{static} käytettynä funktioiden sisällä.

C:n käsittelee tietueiden ja taulukoiden alustamista identtisellä syntaksilla.
Purkka erottaa nämä kaksi syntaksia erikseen ohjelman~\ref{fig:structinit}
tavalla, jotta alustaessa alustettavan datatyypin tyyppi olisi selkeästi
näkyvissä myös tyyppi-inferenssiä käytettäessä.

Suurin osa C:n lauseista on Purkassa lausekkeita. Erityisesti \texttt{if/else}
on C:ssä lause, mutta Purkassa lauseke. \hl{Tähän tekstiä, miten tuo muunnetaan
C:ksi turvallisesti}

\subsection{Makrot}

\hl{Liian lyhyt numeroiduksi aliluvuksi}

\hl{Todo: speksi makroista, tai ainakin lisää selitystä. Kääntäjässä ei ole
toistaiseksi mitään tehtynä Purkka-makrojen eteen.}

Koska Purkan tulee olla myös makrojen osalta C-yhteensopiva, Purkka osaa
laajentaa C-makroja. Purkka-kääntäjä pystyy muuntamaan makrokutsun
C-lähdekoodiksi, laajentamaan sen C-esikäsittelijällä ja muuntamaan makron
laajennettu muoto takaisin Purkka-koodiksi.

Purkassa on myös oma makrojärjestelmä, joka toimii hahmotunnistuksella ja
rekursiolla.\footnote{Referenssikääntäjään (ks. luku \ref{sec:results}) ei ole
toteutettu makroja.} Jos makrot eivät sisällä rekursiota tai hahmontunnistusta,
ne voidaan muuntaa C-makroiksi.

\hl{Teoriassa myös hahmontunnistuksen ja rekursion voisi muuntaa C-makroiksi,
käyttäen hyväksi C-makrojen nurkkatapauksia.}

\subsection{Suoritusaikaiset ominaisuudet ja laajennokset}

Purkka ei sisällä yhtään suoritusaikaista ominaisuutta, joita ei ole C:ssä.
Syntaksi kuitenkin sisältää \texttt{pragma}-avainsanan, jota voidaan käyttää
vastaavasti kuin C:n esikäsittelijän pragmaa erilaisten laajennosten
käyttämiseen. Esimerkiksi OpenMP-laajennosta käytetään pragmojen läpi.

Useat C-toteutukset sisältävät erilaisia laajennoksia, joiden tarkoituksena on
mahdollistaa eilaisten alustariippuvaisten ominaisuuksien käyttö. Benchmarks
gamessa yksi käytetyimmistä laajennoksista on SIMD-tyypit, joita varten
esimerkiksi GCC-kääntäjällä on oma syntaksinsa. GCC:llä SIMD-tyypit voidaan
määritellä käyttämällä \texttt{\_\_attribute\_\_((vector\_size))} -määrettä.
Purkka osaa käyttää useita GCC:n laajennoksia.

Sulkeumien toteutus olettaa, että C-kääntäjä tukee laajennoksena sulkeumia.
\hl{Tähän (tai muualle) lause lambdojen ja sulkeumien erosta?}

\subsection{Ohjelmointikielen kääntäminen}

Purkan kääntäminen C-koodiksi C-koodiksi on hieman normaalia kääntämistä
monimutkaisempaa. Koska Purkan tulee pystyä muuntamaan Purkka-koodia C-koodiksi
mutta myös C-koodia Purkka-koodiksi makrojen laajentamisen myötä, kääntäjän
pitää ymmärtää kahta ohjelmointikieltä yhden sijaan, sekä muuntamaan niitä
toisikseen. Kuvassa~\ref{fig:compilerarch} on kaavio Purkan kääntämisestä.

Suurimman osan purkan syntaksipuista saa käännettyä lähes identtisiksi C:n
syntaksipuiksi, mutta muutamat ominaisuudet vaativat enemmän työtä. Suurin
näistä on tyyppipäättely. Jotkut muut ominaisuudet vaativat myös
monimutkaisempia muutoksia, kuten \texttt{if}-lausekkeet sekä lambdalausekkeet.
Näistä \texttt{if}-lausekkeet käännetään käyttäen välimuuttujaa.
Lambdalausekkeet taas käännetään nostamalla lambda erilliseksi funktioksi ja
korvaamalla lambda osoittimella tähän funktioon.

\hl{2 viimeistä virkettä pois?}


\begin{figure}[ht!]
        \footnotesize
        \begin{adjustbox}{center}
        \begin{tikzpicture}[-{Latex[length=2mm,width=3mm]},auto, main node/.style={draw,fill=white},align=center]
            \tikzstyle{ann} = [rounded corners,fill=black!4,draw=black]
            \tikzset{
                -|/.style={to path={-| (\tikztotarget)}},
                |-/.style={to path={|- (\tikztotarget)}},
            }

            \node[main node,text width=3cm,fill=black!10] (core) {Tiedosto syötetään kääntäjälle};

            \node[main node,text width=3.3cm] (purkkaparser) [right = of core] {Purkka-jäsentäjä};

            \node[main node] (cpurkka) [right = of purkkaparser,text width=3.5cm] {Muuntaja C-syntaksipuusta Purkka-syntaksipuuksi};
            \node[main node] (coremacro) [above = of cpurkka,text width=3.5cm] {Muuntaja Purkka-lausekkeista C-syntaksipuiksi};
            \node[main node,text width=3.5cm] (purkkac) [below = of cpurkka] {Muuntaja Purkka-syntaksipuusta C-syntaksipuuksi};
            \coordinate[above left = of coremacro] (phantom);

            \node[draw = none] (phantom1) [above = of coremacro, text width=3.5cm] {};
            \node[draw = none] (phantom3) [left = of phantom1, text width=3.3cm] {};
            \node[draw = none] (phantom2) [right = of phantom1, text width=2.3cm] {};

            \node[main node] (preprocessor) [right = of coremacro,text width=2.3cm] {C-esikäsittelijä};
            \node[main node] (cparser) [right = of cpurkka,text width=2.3cm] {C-jäsentäjä};

            \node[main node,text width=3.3cm] (cformat) [left = of purkkac] {C-syntaksipuun muuntaminen lähdekoodiksi};
            \node[main node,fill=black!10] (done) [left = of cformat] {Tiedosto on käännetty};

            \coordinate (phantom4) at ($(purkkaparser)!0.5!(purkkac)$);

            \draw (purkkaparser.170) |- (phantom) node[blur shadow={shadow blur steps=5},ann,above right = 0.2cm and 0cm]  {Purkka-koodi sisällyttää C-tiedoston} -| (preprocessor); 
            \draw (purkkaparser.130) |- node[blur shadow={shadow blur steps=5},ann,text width=2.7cm,above right = 0.2cm and -0.4cm] {Purkka-koodi kutsuu C-makroa} (coremacro);
            \draw (purkkaparser) |- (phantom4) -| (purkkac);

            \path[every node/.style={font=\sffamily\small},-{Latex[length=2mm,width=3mm]}]
            (core) edge (purkkaparser)
            (coremacro) edge (preprocessor)
            (preprocessor) edge (cparser)
            (cparser) edge (cpurkka)
            (cpurkka) edge (purkkaparser)
            (purkkac) edge (cformat)
            (cformat) edge (done)
            ;

            \draw node[above = of phantom1] {\textbf{AST-muuntaja}};
            \draw node[above = of phantom2] {\textbf{C-kääntäjä}};
            \draw node[above = of phantom3] {\textbf{Purkka-kääntäjä}};
            \begin{scope}[on background layer]
                \draw[thick,dotted,fill=black!5] ($(phantom1.north west)+(-0.3,2)$)  rectangle ($(purkkac.south east)+(0.3,-0.4)$);
                \draw[thick,dotted,fill=black!5] ($(phantom2.north west)+(-0.3,2)$)  rectangle ($(cparser.south east)+(0.3,-0.4)$);
                \draw[thick,dotted,fill=black!5] ($(phantom3.north west)+(-0.3,2)$)  rectangle ($(purkkaparser.south east)+(0.3,-0.4)$);
            \end{scope}
        \end{tikzpicture}
        \end{adjustbox}

        %\caption{Kaavio Purkan kääntämisestä C:ksi.}
        \label{fig:compilerarch}
\end{figure}
