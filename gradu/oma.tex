\section{Kieli, joka ratkaisee kaikki ongelmat} 

\subsection{Ominaisuuksia}

Muistinhallinta manuaalinen koska yksinkertainen toteutuksen kannalta + antaa
absoluuttisen kontrollin

Käännetään ylläpidettäväksi C:ksi jolloin voi tiputtaa kielen jos haluaa \\
-> samalla tuki kaikille C:n alustoille, pl. kaikki jotka ei toteuta C:n speksiä oikein \\
-> saisiko samalla tuen esim. Arduinon C:lle?

Tyypitys täysin yhteensopivaksi C:n kanssa - voisiko tähän saada esim.
Rustissa olevan Box<T>-tyypin (vrt. Haskellin Maybe, Javan Optional<T>), jossa \\
NULL == Nothing? Pitäisi keksiä hyvä syntaksi, että olisi extendattava \\
-> Adasta vaikutteita?

...mutta non-null oletuksella on hyvä syntaksimuutos, esim.
foo(arg ?*int) void \{\}

Makroihin jotain tehokasta ja käytettävää, Rustista inspistä \\
-> Rust: Makrot parsii AST:tä a la lisp \\
-> C: Makrot yksinkertaista stringien läimimistä ympäriinsä \\
-> Saisiko tähän C:n yksinkertaiset makrot ja Rustin tehokkaat makrot
yhdistettynä?

Calling convention pitää ratkaista jotenkin, esim. Windowsissa 2 eri
konventiota \\
-> \_\_attribute\_\_() on ainakin jokseenkin portable (GCC + Clang tukee),
calling conventiot kuitenkin riippuu alustasta ja kääntäjästä myös C:ssä

Namespacet on hankalia, vaatii name manglingia -> epäyhteensopivuutta / bloat /
yms, todnäk pakko jättää pois

Natiivi .h-import/.h-export must-have

\subsection{Syntaksi}

Standardikirjasto minimiin, tyypeistä extendattavat: syntaksisokeria
``metodien'' toteuttamiseen, eli oikeasti (inline-)funktioita jotka ottavat
sisään *structin \\
-> voi importata uusia metodeja tyyppeihin 0-overheadilla

Syntaksi: Tyyppisyntaksista selkeämpi; esim. ''int foo[]`` -> ''foo: [Int]``,
''void (*fp)(int arg, char arg2)`` -> ''fp: (int arg, char arg2) -> void``

... tai sitten mahd. lähelle C:tä -> helpompi siirtymä

Tyyppi-inferenssi? Auttaisi lambdojen kirjoittamista

Pattern matching switchin tilalle, kääntyy switchiksi tai ifelse-ketjuksi

Go:n defer on hieno, mutta tulisi tähän korkeintaan rajoitettuna versiona -
while(turingComplete()) defer foo(); on mahdoton käsitellä ilman automaattista
muistinhallintaa \\
-> voisi kuitenkin olla hyvä, koska todella yleinen use case manuaalisella
muistinhallinnalla \\
-> Saisiko jotenkin ilmaistua, missä ptr on säilötty? Yksinkertaiset caset
voisi hanskata \\
-> tai sitten alloca()n raskasta väärinkäyttöä, ja todetaan että jos hyppää
ulos niin niitä ei ajeta

Sulkeumat olis hyvä saada aikaan, pitää pohtia mahdollisuuksia - C:n
perustoteutuksessa heitellään ympäriinsä void *:ta callbackien yhteydessä,
mutta muitakin keinoja on

GCC \url{https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html} epämääräinen
hack omilla rajoituksillaan, mutta korkea perf

\subsection{Toolaus}

Go:ssa hyvä esimerkki; paketinhallinta, lintteri, fmt, kääntäjä yms yhden
komennon takana

Pitää olla mahdollisimman helppo interfacetus IDEille \\
-> Kääntäjä voi tuutata esim. AST, linttaus, tyypit, identifierit... nopeasti

\subsection{Stage 0}

Kirjoitetaan kääntäjä C:llä ja sitten porttaus hiljalleen tähän kieleen \\
-> Real-life -esimerkki kielestä siirtymiseen \\
-> Jos jaksaa odottaa, ei tarvitse bootstrap-kääntäjää, vaan voi kääntää
C-kääntäjällä gittihistoriasta 
