\section{Uuden ohjelmointikielen vertaaminen muihin ohjelmointikieliin}

\hld{Tässä luvussa uutta ohjelmointikieltä vertaillaan muihin tutkielmassa
käsiteltyihin ohjelmointikieliin, ja kerrotaan, miksi tai miksei se päihitä
C:tä vertailuehtojen mukaisesti.}

\subsection{Vertailun tulokset}
\label{sec:results}

Tätä tutkielmaa varten on toteutettu kääntäjä, joka kääntää ohjelmat
Purkka-kielestä C-kieleen \citep{purkka}. Nopeimmat Benchmarks Gamen
C-toteutukset on käännetty Purkka-kielelle. Nämä ohjelmat on sitten käännetty
Purkka-kääntäjällä takaisin C:ksi, ja käännetty sitten GCC-kääntäjällä
vastaavilla asetuksilla kuin verrattavat C-ohjelmat.
Kuvassa~\ref{fig:purkkabenchmarksgame} verrataan Purkka-toteutuksia nopeimpaan
C-ohjelmaan. Koska Purkka-toteutukset on muunnettu nopeimmasta C-toteutuksesta
ja käännetty takaisin lähes identtiseen muotoon, suoritusajan ja muistinkäytön
tulisi olla täsmälleen samat kuin alkuperäisen C-toteutuksen.

Suorituskykymittaukset mittaavat ainoastaan prosessoriin ja muistinkäyttöön
liittyiviä mittauksia, eivätkä esimerkiksi näytönohjaimella suoritettua
laskentaa.

\hl{Täydennykset tähän kun on lopulliset mittaukset: } Suorituskykymittaukset
on tehty \hl{ABC}-koneella \hl{Ubuntu/Arch}-käyttöjärjestelmällä Linux 4.x.x
-kernelillä. Mittaustietokoneessa oli neliytiminen Intel \hl{i7 XXXX}
-prosessori HyperThreading-tuella (3.x GHz) ja XX gigatavua DDR3-muistia.
Mittaukset on toteutettu suorittamalla ohjelma suurimmalla syötteellä \hl{x}
kertaa \hl{(5? ehkä enemmän.)}, ja mittaamalla kunkin ajon viemä aika ja
muistinkäyttö. Muistinkäyttö on mitattu 200 millisekunnin välein
\texttt{libgtop2}-kirjastolla, ja kunkin ajon muistinkäytöksi on merkitty
suurin mitattu muistikäyttö.

Kuvaajista nähdään, että Purkka on täsmälleen yhtä tehokas kieli kuin C, eikä
se vie enempää muistia. Pienet eroavaisuudet suuntaan ja toiseen on
selitettävissä testauksen aihuttamalla luonnollisella vaihtelulla. Kiintoisasti
Purkalla toteutettu \texttt{fannkuchredux}-koe on kuitenkin noin 50\% nopeampi
kuin C:llä toteutettu lähes identtinen versio, ja \texttt{nbody}-koe vie vie
vain 80\% muistia verrattuna C-toteutukseen. \hl{todo: Johtuuko tuo
mittausvirheistä, vaiko kääntäjän pienistä muutoksista esim.
\texttt{static}-avainsanan lisäilyyn liittyen?} Purkka-tiedostot ovat
keskimäärin 6\% pienempiä kuin vastaavat C-tiedostot. Suurimmat kokoerot
tiedostoissa tulevat muuttujien määrittelyistä sekä tyyppi-inferenssistä.
Kuvassa~\ref{fig:declarations} esitellään esimerkkejä Purkan
yksinkertaisemmista määrittelyistä monimutkaisemmissa määrittelyissä.

\begin{figure}[ht!]
    \begin{adjustbox}{center}
        \begin{tabular}{@{} m{0.55\textwidth} m{0.55\textwidth} @{}} \toprule
            Purkka-määrittely ja C-määrittely & Selite \\ \midrule

            \texttt{let a: u32; \newline unsigned int a;} & Epänegatiivinen 32-bittinen kokonaisluku \\
            \noalign{\vspace{0.2cm}}

            \texttt{let a, b: [\&i8;5]; \newline signed char *a[5], *b[5];} & Taulukko viidestä osoitinmuuttujasta \newline 8-bittiseen kokonaislukuun \\
            \noalign{\vspace{0.2cm}}

            \texttt{const a = ["1", "2", "3"]; \newline const char * const a[] = \{"1", "2", "3"\};} & Kolmen merkkijonon taulukon vakiomuuttuja \\
            \noalign{\vspace{0.2cm}}

            \texttt{let a = fun (a, b) => a + b; \newline int a(int a, int b) \{ return a + b; \}} & Funktio, joka laskee argumenttiensa summan \\
            \noalign{\vspace{0.2cm}}

            \bottomrule
        \end{tabular}
    \end{adjustbox}
    \label{fig:declarations}
    \caption{Purkan muuttujien määrittelyt verrattuna C:n vastaaviin
    määrittelyihin.}
\end{figure}


\begin{figure}[ht!]
    \begin{adjustbox}{center}
        \begin{minipage}{1.25\textwidth}
        \input{data/benchmarkscpu2.tex}
        \end{minipage}
    \end{adjustbox}

    \begin{adjustbox}{center}
        \begin{minipage}{1.25\textwidth}
        \input{data/benchmarksmem2.tex}
        \end{minipage}
    \end{adjustbox}

    \begin{adjustbox}{center}
        \begin{minipage}{1.25\textwidth}
        \input{data/benchmarkslines2.tex}
        \end{minipage}
    \end{adjustbox}
    \caption{
        Benchmarks Gamen ohjelmiin perustuvat kuvaajat Purkalla kirjoitettujen ohjelmien
        suorituskyvystä, muistinkäytöstä ja ohjelmien koosta verrattuna C:llä
        kirjoitettujen ohjelmien tuloksiin.}
    \label{fig:purkkabenchmarksgame}
\end{figure}

\FloatBarrier

\subsection{Johtopäätökset ja vertailun arviointi}

Purkka on vertailun ainoa kieli, joka on yhtä tehokas kuin C. Tämä johtunee
pitkälti siitä, että Purkka käännetään lähes identtisenä C:ksi, eikä tarjoa
ajoaikaisia ominaisuuksia, jotka hidastaisivat kieltä. Purkka ei kuitenkaan
päihitä C:tä tutkimuksen määrittelyn mukaisesti, vaan on suorituskyvyltään
täsmälleen yhtä tehokas kuin C.

Suorituskykymittaukset eivät kuitenkaan vastaa todellista maailmaa, sillä ne
usein mittaavat vain yksittäistä pientä osa-aluetta, kuten yksittäisten
operaatioiden nopeutta monimutkaisten ohjelmistojen sijaan. Lisäksi
suorituskykymittaukset ovat usein epätarkkoja, sillä monimutkaiset
moniajoympäristöt eivät mahdollista deterministisiä mittauksia.

Purkkaa todennäköisesti ei oteta käyttöön, sillä se ei tarjoa merkittäviä
parannuksia C:hen, vaan mahdollistaa lähinnä hieman lyhyemmän lähdekoodin.
Tämän lisäksi Purkan toteuttaja on yksittäinen opiskelija, kun taas esimerkiksi
Go-kielen ja Rustin toteuttajat ovat kokeneita ohjelmointikielten
suunnittelijoita, jonka lisäksi kieliä ylläpidetään aktiivisesti tunnettujen
organisaatioiden toimesta. Tämä on todennäköisesti myös syy sille, miksi
esimerkiksi LISP/c~\citep{clisp1}, C-Mera~\citep{clisp2}, Carp~\citep{clisp3}
ja Nymph~\citep{nymph} ovat jääneet ilman laajempaa huomiota.

Tutkimuksesta voidaan kuitenkin päätellä, että C:tä parempi kieli on
todennäköisesti toteutettavissa. Käännösaikaista turvallisuutta voi parantaa
tiukemmalla tyyppijärjestelmällä ilman ajoaikaisia haittoja. Tarkemmilla
tyyppimäärittelyillä voi myös tehdä optimointeja, esimerkiksi vaatimalla
osoitinargumentit aina ei-tyhjiksi osoittimiksi.

\hld{Jos tutkielmassa on mahdollisia puutteita, tai sen tulokset eivät
välttämättä tutkielman rajoituksista johtuen päde tutkielman ulkopuolella,
tässä aliluvussa perustellaan syitä tälle.}

\hld{Erityisesti tutkimusaiheen rajaus ei välttämättä yleisty tutkimuksen
ulkopuolelle, sillä ohjelmointikielten valintaan liittyy usein monimutkaisia
syitä, kuten aikaisempi kokemus tai ohjelmoijan henkilökohtainen mieltymys
johonkin kieleen, eikä projekteissa käytettyjä ohjelmointikieliä valita
pelkästään kielen ominaisuuksien perusteella.}

\hld{Jos tutkielmassa ilmenee mahdollisia jatkotutkimuskohteita, niistä
kerrotaan tässä aliluvussa.}
