\section{Uuden ohjelmointikielen vertaaminen C:hen}

\hl{Benchmarkit: todistus ettei toteutus hidastu}

\hl{Tässä luvussa uutta ohjelmointikieltä vertaillaan muihin tutkielmassa
käsiteltyihin ohjelmointikieliin, ja kerrotaan, miksi tai miksei se päihitä
C:tä vertailuehtojen mukaisesti.}

\hl{ Luku 5: Otsikko kertoo, että uutta kieltä verrataan muihin kieliin, mutta
eihän sitä nähdäksen verrata kuin C:hen. Ja nythän vertailun tulokset koskevat
vain suoritusaikaisia ominaisuuksia - entä kaikki muut parannukset C:hen
verrattuna (luku 2.3)? }

\subsection{Vertailun tulokset}
\label{sec:results}

\hl{Ovatko suorituskykymittaukset relevantteja?}

Tätä tutkielmaa varten on toteutettu kääntäjä, joka kääntää ohjelmat
Purkka-kielestä C-kieleen \citep{purkka}. Nopeimmat Benchmarks Gamen
C-toteutukset on käännetty Purkka-kielelle. Nämä ohjelmat on sitten käännetty
Purkka-kääntäjällä takaisin C:ksi, ja käännetty sitten GCC-kääntäjällä
vastaavilla asetuksilla kuin verrattavat C-ohjelmat.
Kuvassa~\ref{fig:purkkabenchmarksgame} verrataan Purkka-toteutuksia nopeimpaan
C-ohjelmaan. Koska Purkka-toteutukset on muunnettu nopeimmasta C-toteutuksesta
ja käännetty takaisin lähes identtiseen muotoon, suoritusajan ja muistinkäytön
tulisi olla täsmälleen samat kuin alkuperäisen C-toteutuksen.

Suorituskykymittaukset mittaavat ainoastaan prosessoriin ja muistinkäyttöön
liittyiviä mittauksia, eivätkä esimerkiksi näytönohjaimella suoritettua
laskentaa. Mittaukset tehdään vain yksittäisillä kääntäjäversioilla, joten
mittaukset eivät välttämättä päde muilla saman ohjelmointikielen kääntäjillä.

\hl{Täydennykset tähän kun on lopulliset mittaukset: } Suorituskykymittaukset
on tehty \hl{ABC}-koneella \hl{Ubuntu/Arch}-käyttöjärjestelmällä Linux 4.x.x
-kernelillä. Mittaustietokoneessa oli neliytiminen Intel \hl{i7 XXXX}
-prosessori HyperThreading-tuella (3.x GHz) ja XX gigatavua DDR3-muistia.
\hl{Kääntäjäversiot ym}

Mittaukset on toteutettu suorittamalla ohjelma suurimmalla syötteellä \hl{x}
kertaa, ja mittaamalla kunkin suorituksen viemä aika ja muistinkäyttö.
Muistinkäyttö on mitattu 200 millisekunnin välein
\texttt{libgtop2}-kirjastolla, ja kunkin suorituksen muistinkäytöksi on
merkitty suurin mitattu muistikäyttö.

Kuvaajista nähdään, että Purkka on täsmälleen yhtä tehokas kieli kuin C, eikä
se vie enempää muistia. Pienet eroavaisuudet suuntaan ja toiseen on
selitettävissä testauksen aihuttamalla luonnollisella vaihtelulla. Kiintoisasti
Purkalla toteutettu \texttt{fannkuchredux}-koe on kuitenkin noin 50\% nopeampi
kuin C:llä toteutettu lähes identtinen versio, ja \texttt{nbody}-koe vie vie
vain 80\% muistia verrattuna C-toteutukseen. \hl{todo: Johtuuko tuo
mittausvirheistä, vaiko kääntäjän pienistä muutoksista esim.
\texttt{static}-avainsanan lisäilyyn liittyen?} Purkka-tiedostot ovat
keskimäärin 6\% pienempiä kuin vastaavat C-tiedostot. Suurimmat kokoerot
tiedostoissa tulevat muuttujien määrittelyistä sekä tyyppi-inferenssistä.
Kuvassa~\ref{fig:declarations} esitellään esimerkkejä Purkan
yksinkertaisemmista määrittelyistä monimutkaisemmissa määrittelyissä.

\begin{figure}[ht!]
    \begin{adjustbox}{center}
        \begin{tabular}{@{} m{0.55\textwidth} m{0.55\textwidth} @{}} \toprule
            Purkka-määrittely ja C-määrittely & Selite \\ \midrule

            \texttt{let a: u32; \newline unsigned int a;} & Epänegatiivinen 32-bittinen kokonaisluku \\
            \noalign{\vspace{0.3cm}}

            \texttt{let a, b: [\&i8;5]; \newline signed char *a[5], *b[5];} & Taulukko viidestä osoitinmuuttujasta \newline 8-bittiseen kokonaislukuun \\
            \noalign{\vspace{0.3cm}}

            \texttt{const a = ["1", "2", "3"]; \newline const char * const a[] = \{"1", "2", "3"\};} & Kolmen merkkijonon taulukon vakiomuuttuja \\
            \noalign{\vspace{0.3cm}}

            \texttt{let a = fun (a, b) => a + b; \newline int a(int a, int b) \{ return a + b; \}} & Funktio, joka laskee argumenttiensa summan \\ \bottomrule
        \end{tabular}
    \end{adjustbox}
    \label{fig:declarations}
    \caption{Purkan muuttujien määrittelyt verrattuna C:n vastaaviin
    määrittelyihin.}
\end{figure}


\begin{figure}[ht!]
    \begin{adjustbox}{center}
        \begin{minipage}{1.25\textwidth}
        \input{data/benchmarkscpu2.tex}
        \end{minipage}
    \end{adjustbox}

    \begin{adjustbox}{center}
        \begin{minipage}{1.25\textwidth}
        \input{data/benchmarksmem2.tex}
        \end{minipage}
    \end{adjustbox}

    \begin{adjustbox}{center}
        \begin{minipage}{1.25\textwidth}
        \input{data/benchmarkslines2.tex}
        \end{minipage}
    \end{adjustbox}
    \caption{
        Benchmarks Gamen ohjelmiin perustuvat kuvaajat Purkalla kirjoitettujen ohjelmien
        suorituskyvystä, muistinkäytöstä ja ohjelmien koosta verrattuna C:llä
        kirjoitettujen ohjelmien tuloksiin.}
    \label{fig:purkkabenchmarksgame}
\end{figure}

\FloatBarrier

\subsection{Johtopäätökset ja vertailun arviointi}

Purkka on vertailun ainoa kieli, joka on yhtä tehokas kuin C. Tämä johtunee
pitkälti siitä, että Purkka käännetään lähes identtisenä C:ksi, eikä tarjoa
suoritusaikaisia ominaisuuksia, jotka hidastaisivat kieltä. Purkka ei kuitenkaan
päihitä C:tä tutkimuksen määrittelyn mukaisesti, vaan on suorituskyvyltään
täsmälleen yhtä tehokas kuin C.

Suorituskykymittaukset eivät kuitenkaan vastaa todellista maailmaa, sillä ne
usein mittaavat vain yksittäistä pientä osa-aluetta, kuten yksittäisten
operaatioiden nopeutta monimutkaisten ohjelmistojen sijaan. Lisäksi
suorituskykymittaukset ovat usein epätarkkoja, sillä monimutkaiset
moniajoympäristöt eivät mahdollista deterministisiä mittauksia.

Mittaukset koskevat vain yksittäisiä ohjelmia ajettuna tietyssä ympäristössä
tietyllä kääntäjällä. Ne eivät siis anna kattavaa kuvaa ohjelmointikielistä,
vaan mittaustuloksia yksittäisen kääntäjätoteutuksen kääntämistä ohjelmista.
Kääntäjät voivat käyttää jopa yksittäisten versioiden välillä erilaisia
optimointeja, jotka voivat nopeuttaa tai hidastaa ohjelmaa juuri mitatulla
syötteellä, mikä pienentää tulosten vertailukelpoisuutta. Kääntäjät voivat
myös toimia paremmin tai huonommin erilaisilla tietokonearkkitehtuureilla,
jolloin esimerkiksi prosessorin valinta vaikuttaa mittaustuloksiin.

Purkkaa todennäköisesti ei oteta käyttöön, sillä se ei tarjoa merkittäviä
parannuksia C:hen, vaan mahdollistaa lähinnä hieman lyhyemmän lähdekoodin.
Tämän lisäksi Purkan toteuttaja on yksittäinen opiskelija, kun taas esimerkiksi
Go-kielen ja Rustin toteuttajat ovat kokeneita ohjelmointikielten
suunnittelijoita, jonka lisäksi kieliä ylläpidetään aktiivisesti tunnettujen
organisaatioiden toimesta. Tämä on todennäköisesti myös syy sille, miksi
esimerkiksi LISP/c~\citep{clisp1}, C-Mera~\citep{clisp2}, Carp~\citep{clisp3}
ja Nymph~\citep{nymph} ovat jääneet ilman laajempaa huomiota.

Tutkimuksesta voidaan kuitenkin päätellä, että C:tä parempi kieli on
todennäköisesti toteutettavissa. Käännösaikaista turvallisuutta voi parantaa
tiukemmalla tyyppijärjestelmällä ilman suoritusaikaisia haittoja. Tarkemmilla
tyyppimäärittelyillä voi myös tehdä optimointeja, esimerkiksi vaatimalla
osoitinargumentit aina ei-tyhjiksi osoittimiksi.

Osaa Purkassa olevista ominaisuuksista voisi ottaa käyttöön jopa uusissa C:n
versioissa. Tyyppipäättelyn lisääminen esimerkiksi korvaamalla käyttämättömän
\texttt{auto}-avainsanan tarkoittamaan pääteltyä tyyppiä voisi auttaa
moderneja C-kääntäjiä käyttävien projektien kirjoittamista.
\texttt{gcc}-käyttäjä tukee tyyppi-inferenssiä
\texttt{\_\_auto\_type}-määreellä. Summatyyppien lisääminen laajennoksena
\texttt{enum}- tai \texttt{union}-tyyppisyntaksiin ei vaikuta tämänhetkisiin
standardien mukaisiin ohjelmiin, mutta mahdollistaisi kehittäessä summatyyppien
käytön. Suurempia syntaktisia muutoksia, kuten tyyppisyntaksin
uudelleenkirjoitusta tuskin pystyy toteuttamaan säilyttäen yhä tuen nykyiselle
C:lle.

\hl{Tässä on tärkeä teema mutta jää tässä vain toteamukseksi, pidempi analyysi
ja esimerkit syventäisivät käsittelyä}

\hrule

\hl{Jos tutkielmassa on mahdollisia puutteita, tai sen tulokset eivät
välttämättä tutkielman rajoituksista johtuen päde tutkielman ulkopuolella,
tässä aliluvussa perustellaan syitä tälle.}

\hl{Erityisesti tutkimusaiheen rajaus ei välttämättä yleisty tutkimuksen
ulkopuolelle, sillä ohjelmointikielten valintaan liittyy usein monimutkaisia
syitä, kuten aikaisempi kokemus tai ohjelmoijan henkilökohtainen mieltymys
johonkin kieleen, eikä projekteissa käytettyjä ohjelmointikieliä valita
pelkästään kielen ominaisuuksien perusteella.}

\hl{Jos tutkielmassa ilmenee mahdollisia jatkotutkimuskohteita, niistä
kerrotaan tässä aliluvussa.}
