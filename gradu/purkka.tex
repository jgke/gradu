\section{Purkka-ohjelmointikieli}
\label{sec:purkka}

\hl{Mitä valintoja voi tehdä ilman hidastusta? Mitä ei saa tehdä?}

Tässä luvussa määritellään Purkka-ohjelmointikieli.

\hl{Uudelleenstrukturointi: Osoitetaan hyviin ja huonoihin puoliin tutkielman
aiemman materiaalin kanssa, ja perustellaan siten valinnat}

\hl{ Luku 4: Iso asia on se, että Purkka-kielen vaatimuksia ei selitetä
kootusti missään. Asioita pitää nyt lukea rivien välistä. Luvun 4 alkuhan olisi
loistava paikka esittää kielen vaatimukset. Sitten olisi helppo arvioida
lopputulosta niitä vasten }

\subsection{Tyypit}

Jotta yhteensopivuus C:n kanssa olisi joustavaa, Purkan tyyppijärjestelmä
muodostetaan mahdollisimman paljon C:n kaltaiseksi. C:n tyyppisyntaksi sisältää
useita erilaisia tapoja ilmaista samaa pohjatyyppiä -- esimerkisi
\texttt{long}, \texttt{signed~long}, \texttt{long~int} ja
\texttt{signed~long~int} ilmaisevat kokonaislukutyyppiä, joka pystyy
sisältämään ainakin luvut $[-(2^{31} - 1), 2^{31}-1]$\footnote{Käytännössä
modernit toteutukset käyttävät kahden komplementtia kokonaislukujen
ilmaisemiseen, jolloin 32-bittinen kokonaislukumuuttuja voi sisältää luvut
$[-2^{31}, 2^{31}]$.}\citationneeded. Nämä tyypit ovat kuitenkin standardien
mukaisessa C:ssä keskenään täysin vaihdettavissa, eli kielen ei tarvitse pystyä
kääntymään jokaiseen mahdolliseen vaihtoehtoon. Perustyypit ovat hyvin lähellä
Rustin pohjatyyppejä\citationneeded. Purkka tarvitsee erikseen tyypit
\texttt{char}, \texttt{i8} ja \texttt{u8}, sillä C:n \texttt{char}-tyyppiä ei
ole määritelty tarkemmin joko kokonaisluvuksi tai 
\texttt{signed char} ja \texttt{unsigned char} ovat erillisiä tyyppejä.

\hl{Nämä tyypit ovat... pidempi selitys}

\hl{char-tyyppin sign -> sekava ja epäselvä }

Koska kieli ei voi erota C:stä suoritusaikaisesti, tyypitys on hyvin lähellä
C:n tyypitystä.

Tyypit:
 C + tagged union + non-nullable pointer

kuinka tagged union käännetään C:ksi? Entä non-nullable ptr?

tyyppipäättely

Mitä optimointeja non-null tarjoaa? Entä tagged union?

\subsection{Tyyppipäättely}

Purkka käyttää tyyppipäättely toteuttamisen pohjana yleisesti käytettyä
Damas-Hindley-Milner -algoritmia~\citep{hindley, milner, damas}.

Jotta päättelyalgoritmi toimisi lineaariaikaisesti suhteessa syötteen kokoon,
osassa lausekkeista muuttujien tyyppien tulee olla tiedossa sillä hetkellä, kun
lausekkeen tyyppiä selvitetään. Yhteen- ja vähennyslasku voi vaatia myös
tyyppimäärittelyt, jos yhteenlaskettavat parametrit ovat osoittimia\footnote{C
sallii osoitinmuuttujan ja kokonaisluvun yhteen- ja vähennyslaskun sekä kahden
osoittimen vähennyslaskun.}. Näistä selkein esimerkki on struct-tyyppien kentän
käyttäminen, jonka tyyppiä kääntäjä ei suostu päättelemään, jos muuttujan
tyyppi ei ole tiedossa. Koodissa~\ref{fig:structinfer} on kaksi esimerkkiä
tyyppipäättelystä struct-muuttujiin: ensimmäisessä esimerkissä
tyyppipäättely onnistuu, mutta toisessa ei.

\begin{listing}[ht!]
    \inputminted{Rust}{koodi/infer.prk}
    \caption{Esimerkki tyyppipäättelystä.}
    \label{fig:structinfer}
\end{listing}

\FloatBarrier

\hl {Esimerkissä kysymysmerkkejä. Selitys auki}

\hl{Tämä vaatii \textbf{paljon} lisää avaamista, selittämistä ym. tekstiä.
Lisäksi pitää vahvistaa, että Purkka-kääntäjä oikeasti toimii näiden
perusteella, eikä \emph{melkein} identtisten päättelysääntöjen avulla.}

\subsection{Syntaksi}

\hl{Tähän osioon voisi tehdä enemmän esimerkkejä.}

Purkan syntaksi on hyvin samankaltainen C:n syntaksiin verrattuna. Suurimmat
erot C:hen liittyvät tyyppien kirjoittamiseen.

Funktiomäärittelyt alkavat \texttt{fun}-avainsanalla. Tämä noudattaa usean muun
modernin ohjelmointikielen tapaa aloittaa funktiomäärittely avainsanalla.
Vertailun vuoksi Rust käyttää avainsanaa \texttt{fn}, Go käyttää avainsanaa
\texttt{func} ja Kotlin käyttää avainsanaa \texttt{fun}). Avainsanan
käyttäminen yksinkertaistaa jäsentäjän toteutusta.

Purkka tukee tyyppipäättelyä, joka helpottaa koodin kirjoittamista, kun
kääntäjä pystyy päättelemään muuttujien tyypit. Tyyppisyntaksi itsessään
muistuttaa paljon Rustin tyyppisyntaksia.

\hl{tukee tyyppipäättelyä alleviivattu}

C:n \texttt{static}-avainsana on jaettu käytön mukaisesti kahteen avainsanaan.
Funktiomäärittelyissä ja globaaleissa muuttujissa C:n
\texttt{static}-avainsanaa vastaa Purkan \texttt{pub}-avainsana (''public'' eli
julkinen), mutta käänteisellä merkityksellä: jos \texttt{pub}-avainsanaa ei ole
käytetty, koodi käyttäytyy kuin siihen olisi lisätty C:n
\texttt{static}-avainsana. Funktioiden sisällä Purkka tukee myös
\texttt{static}-avainsanaa, joka toimii samalla tavalla kuin C:n
\texttt{static} käytettynä funktioiden sisällä.

C:n käsittelee tietueiden ja taulukoiden alustamista identtisellä syntaksilla.
Purkka erottaa nämä kaksi syntaksia erikseen ohjelman~\ref{fig:structinit}
tavalla, jotta alustaessa alustettavan datatyypin tyyppi olisi selkeästi
näkyvissä myös tyyppi-inferenssiä käytettäessä.

\begin{listing}[ht!]
    \inputminted{Rust}{koodi/structinit.prk}
    \inputminted{C}{koodi/structinit.c}
    \caption{Tietueen ja taulukon alustaminen Purkassa ja C:ssä.}
    \label{fig:structinit}
\end{listing}

Suurin osa C:n lauseista on Purkassa lausekkeita. Erityisesti \texttt{if/else}
on C:ssä lause, mutta Purkassa lauseke. \hl{Tähän tekstiä, miten tuo muunnetaan
C:ksi turvallisesti}

\subsection{Makrot}

\hl{Liian lyhyt numeroiduksi aliluvuksi}

\hl{Todo: speksi makroista, tai ainakin lisää selitystä. Kääntäjässä ei ole
toistaiseksi mitään tehtynä Purkka-makrojen eteen.}

Koska Purkan tulee olla myös makrojen osalta C-yhteensopiva, Purkka osaa
laajentaa C-makroja. Purkka-kääntäjä pystyy muuntamaan makrokutsun
C-lähdekoodiksi, laajentamaan sen C-esikäsittelijällä ja muuntamaan makron
laajennettu muoto takaisin Purkka-koodiksi.

Purkassa on myös oma makrojärjestelmä, joka toimii hahmotunnistuksella ja
rekursiolla.\footnote{Referenssikääntäjään (ks. luku \ref{sec:results}) ei ole
toteutettu makroja.} Jos makrot eivät sisällä rekursiota tai hahmontunnistusta,
ne voidaan muuntaa C-makroiksi.

\hl{Teoriassa myös hahmontunnistuksen ja rekursion voisi muuntaa C-makroiksi,
käyttäen hyväksi C-makrojen nurkkatapauksia.}

\subsection{Suoritusaikaiset ominaisuudet ja laajennokset}

Purkka ei sisällä yhtään suoritusaikaista ominaisuutta, joita ei ole C:ssä.
Syntaksi kuitenkin sisältää \texttt{pragma}-avainsanan, jota voidaan käyttää
vastaavasti kuin C:n esikäsittelijän pragmaa erilaisten laajennosten
käyttämiseen. Esimerkiksi OpenMP-laajennosta käytetään pragmojen läpi.

Useat C-toteutukset sisältävät erilaisia laajennoksia, joiden tarkoituksena on
mahdollistaa eilaisten alustariippuvaisten ominaisuuksien käyttö. Benchmarks
gamessa yksi käytetyimmistä laajennoksista on SIMD-tyypit, joita varten
esimerkiksi GCC-kääntäjällä on oma syntaksinsa. GCC:llä SIMD-tyypit voidaan
määritellä käyttämällä \texttt{\_\_attribute\_\_((vector\_size))} -määrettä.
Purkka osaa käyttää useita GCC:n laajennoksia.

Sulkeumien toteutus olettaa, että C-kääntäjä tukee laajennoksena sulkeumia.
\hl{Tähän (tai muualle) lause lambdojen ja sulkeumien erosta?}

\subsection{Ohjelmointikielen kääntäminen}

Purkan kääntäminen C-koodiksi C-koodiksi on hieman normaalia kääntämistä
monimutkaisempaa. Koska Purkan tulee pystyä muuntamaan Purkka-koodia C-koodiksi
mutta myös C-koodia Purkka-koodiksi makrojen laajentamisen myötä, kääntäjän
pitää ymmärtää kahta ohjelmointikieltä yhden sijaan, sekä muuntamaan niitä
toisikseen. Kuvassa~\ref{fig:compilerarch} on kaavio Purkan kääntämisestä.

Suurimman osan purkan syntaksipuista saa käännettyä lähes identtisiksi C:n
syntaksipuiksi, mutta muutamat ominaisuudet vaativat enemmän työtä. Suurin
näistä on tyyppipäättely. Jotkut muut ominaisuudet vaativat myös
monimutkaisempia muutoksia, kuten \texttt{if}-lausekkeet sekä lambdalausekkeet.
Näistä \texttt{if}-lausekkeet käännetään käyttäen välimuuttujaa.
Lambdalausekkeet taas käännetään nostamalla lambda erilliseksi funktioksi ja
korvaamalla lambda osoittimella tähän funktioon.

\hl{2 viimeistä virkettä pois?}
