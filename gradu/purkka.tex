\section{Purkka-ohjelmointikieli}
\label{sec:purkka}

\hl{Mitä valintoja voi tehdä ilman hidastusta? Mitä ei saa tehdä?}

\hl{Uudelleenstrukturointi: Osoitetaan hyviin ja huonoihin puoliin tutkielman
aiemman materiaalin kanssa, ja perustellaan siten valinnat}

\hl{ Luku 4: Iso asia on se, että Purkka-kielen vaatimuksia ei selitetä
kootusti missään. Asioita pitää nyt lukea rivien välistä. Luvun 4 alkuhan olisi
loistava paikka esittää kielen vaatimukset. Sitten olisi helppo arvioida
lopputulosta niitä vasten }

\subsection{Purkan suunnitteluperiaatteet}

Luvut~\ref{sec:clyhyesti},~\ref{sec:ctaustaa}~ja~\ref{sec:cominaisuudet}
nostavat tärkeinä C:n ominaisuuksina kielen yksinkertaisuuden ja tehokkuuden,
jotka ovat mahdollistaneet kielen leviämisen järjestelmästä toiseen.
Luvussa~\ref{sec:cominaisuudet} nostetaan tämän lisäksi esiin mahdollisuus
kirjoittaa C-ohjelmia funktio kerrallaan uudella kielellä, jotta kielestä
toiseen siirtyminen olisi ylipäätään mahdollista ilman kohtuutonta
investointia. Luvussa~\ref{sec:ckehitettavat} esitellään lukuisia C:n
syntaktisia ongelmia, jotka voi muuttaa tehden kielestä helppolukuisemman,
kuten tyyppipäättelyn lisääminen ohjelmointikieleen. Myös käännösaikaista
varmennettavuutta voi parantaa lisäämällä esimerkiksi kieleen summatyypit.
Yhteensopivuus nousee myös esiin luvussa~\ref{sec:suosio}, jossa kirjastojen
saatavuus näytetään tärkeäksi ohjelmointikielen valintakriteeriksi.

Uuden kielen määrittelyssä tulee pitää luvun~\ref{sec:abs} kriteerit, jotta
ominaisuuksia päättäessä ei muodostu esimerkiksi yhteensopivuusongelmia C:n
kanssa. Tämä rajoittaakin suurta osaa luvussa~\ref{sec:muut} esiteltyjä
ominaisuuksia, kuten automaattista muistinhallintaa ja poikkeuksia. Monet
ominaisuudet myös monimutkaistaisivat kieltä tarjoamatta kuitenkaan
tehokkuusparannuksia. Yksittäisiä ominaisuuksia kuitenkin pystyy lisäämään,
kuten luvuissa~\ref{sec:go}~ja~\ref{sec:rust} esiintyvät useat paluuarvot sekä
luvussa~\ref{sec:rust} esitellyt summatyypit, sillä näiden sisällyttäminen
kieleen mahdollistaa paremman käännösaikaisen todentamisen ilman
suoritusaikaisia haittoja. Summatyypit voivat myös parantaa ohjelman
tehokkuutta.

Uusi kieli tulisi kääntää C:ksi, jotta sen käyttäminen on mahdollista kaikissa
järjestelmissä, joissa C:tä käytetään. C:ksi kääntäminen myös mahdollistaa
C-yhteensopivien kirjastojen käyttämisen ilman erillistä
yhteensopivuuskerrosta. Kielen tulee myös ymmärtää C:llä kirjoitettuja ohjelmia
sisältäen myös C:llä kirjoitetut otsikkotiedostot. Esimerkiksi POSIX-C:n
\texttt{errno}-muuttuja voi olla määritelty makrona ja \texttt{errno}-muuttujan
käyttäminen ilman esikäsittelijää esimerkiksi viittaamalla suoraan
\texttt{errno}-nimiseen muuttujaan on määrittelemätöntä toimintaa~\citep[s.
234]{POSIX}.

\subsection{Tyypit}

Jotta yhteensopivuus C:n kanssa olisi joustavaa, Purkan tyyppijärjestelmä
muodostetaan mahdollisimman paljon C:n kaltaiseksi. C:n tyyppisyntaksi sisältää
useita erilaisia tapoja ilmaista samaa pohjatyyppiä -- esimerkisi
\texttt{long}, \texttt{signed~long}, \texttt{long~int} ja
\texttt{signed~long~int} ilmaisevat kokonaislukutyyppiä, joka pystyy
sisältämään ainakin luvut $[-(2^{31} - 1), 2^{31}-1]$\footnote{Käytännössä
modernit toteutukset käyttävät kahden komplementtia kokonaislukujen
ilmaisemiseen, jolloin 32-bittinen kokonaislukumuuttuja voi sisältää luvut
$[-2^{31}, 2^{31} - 1]$.}~\citep{C18}. Tyypit kuten \texttt{long} ja
\texttt{signed long} ovat kuitenkin standardien mukaisessa C:ssä keskenään
täysin vaihdettavissa, eli Purkan ei tarvitse pystyä kääntymään jokaiseen
mahdolliseen vaihtoehtoon, vaan tyyppijärjestelmässä voi olla yksi tyyppi joka
vastaa kaikkia \texttt{long}-tyypin vaihtoehtoisia kirjoitusasuja.

C:n \texttt{char}-tyyppi on poikkeus tästä, sillä \texttt{char}, \texttt{signed
char} ja \texttt{unsigned char} ovat kolme erillistä tyyppiä~\citep{C18}.
Merkkijonot koostuvat \texttt{char}-tyyppisistä alkoista, kun taas
\texttt{signed char} ja \texttt{unsigned char} vastaavat tavun kokoista
kokonaislukua ja epänegatiivista kokonaislukua.

Tyyppien kääntäminen C:stä Purkaksi ja takaisin on yksinkertaista: jokaista
C-tyyppiä vastaa täsmälleen yksi Purkka-tyyppi. Jokaiselle Purkan
alkeistyypille taas on määritelty yksi C-tyyppi, johon kyseinen Purkka-tyyppi
käännetään. Liitteessä~\ref{app:purkka} on taulukko C:n ja Purkan tyypeistä. 

C:n alkeistyyppien, osoittimien, taulukoiden ja yhdistetyyppien lisäksi
määritellään ohjelmoinnin tehostamiseksi sekä käännösaikaisen optimoinnin ja
oikeellisuuden parantamiseksi yksittäisiä lisätyyppejä. Nämä tyypit ovat
epätyhjät osoittimet sekä summatyypit.

Ensimmäiseksi määritellään epätyhjä osoitin, joka on osoitin, joka ei salli
arvokseen C:n \texttt{NULL}-arvoa. Tyyppi kääntyy Purkasta C:ksi
yksinkertaisesti vastaavaan osoitintyyppiin. Epätyhjä osoitin mahdollistaa
kääntäjäoptimointeja, jotka eivät muuten olisi mahdollisia. GCC-kääntäjä
mahdollistaa epätyhjät osoittimet
\texttt{\_\_attribute\_\_((nonnull))}-määreellä.

Toiseksi määritellään summatyyppi. Summatyyppi on yhdistelmä C:n
\texttt{struct}, \texttt{union} ja \texttt{enum} -tyypeistä, ja se mahdollistaa
käännösaikaisesti varmennetun \texttt{union}-tyyppien käytön. Summatyypit
mahollistavat lukuisia käännösaikaisesti varmennettuja optimointeja, jotka
eivät olisi mahdollisia ilman kielessä määriteltyjä
summatyyppejä.\citationneeded

\subsection{Syntaksi}

\hl{Tähän osioon voisi tehdä enemmän esimerkkejä.}

Purkan syntaksi on hyvin samankaltainen C:n syntaksiin verrattuna. Tämä helpottaa
kielen oppimista aikaisemman tutkimuksen mukaisesti~\citep{languagelearning}.
Suurimmat erot C:hen liittyvät tyyppien kirjoittamiseen, jossa syntaksia on
muutettu modernien ohjelmointikielten syntaksin mukaiseksi.

Funktiomäärittelyt alkavat \texttt{fun}-avainsanalla. Tämä noudattaa usean muun
modernin ohjelmointikielen tapaa aloittaa funktiomäärittely avainsanalla.
Vertailun vuoksi Rust käyttää avainsanaa \texttt{fn}, Go käyttää avainsanaa
\texttt{func} ja Kotlin käyttää avainsanaa \texttt{fun}). Avainsanan
käyttäminen yksinkertaistaa jäsentäjän toteutusta.

Purkka-kieli sisältää tyyppipäättelyn, joka helpottaa koodin kirjoittamista,
kun kääntäjä pystyy päättelemään muuttujien tyypit. Tyyppisyntaksi itsessään
muistuttaa paljon Rustin tyyppisyntaksia.

C:n \texttt{static}-avainsana on jaettu käytön mukaisesti kahteen avainsanaan.
Funktiomäärittelyissä ja globaaleissa muuttujissa C:n
\texttt{static}-avainsanaa vastaa Purkan \texttt{pub}-avainsana (''public'' eli
julkinen), mutta käänteisellä merkityksellä: jos \texttt{pub}-avainsanaa ei ole
käytetty, koodi käyttäytyy kuin siihen olisi lisätty C:n
\texttt{static}-avainsana. Funktioiden sisällä Purkka tukee myös
\texttt{static}-avainsanaa, joka toimii samalla tavalla kuin C:n
\texttt{static} käytettynä funktioiden sisällä.

C:n käsittelee tietueiden ja taulukoiden alustamista identtisellä syntaksilla.
Purkka erottaa nämä kaksi syntaksia erikseen ohjelman~\ref{fig:structinit}
tavalla, jotta alustaessa alustettavan datatyypin tyyppi olisi selkeästi
näkyvissä myös tyyppi-inferenssiä käytettäessä.

\begin{listing}[ht!]
    \inputminted{Rust}{koodi/structinit.prk}
    \inputminted{C}{koodi/structinit.c}
    \caption{Tietueen ja taulukon alustaminen Purkassa ja C:ssä.}
    \label{fig:structinit}
\end{listing}

Suurin osa C:n lauseista on Purkassa lausekkeita. Erityisesti \texttt{if/else}
on C:ssä lause, mutta Purkassa lauseke. \hl{Tähän tekstiä, miten tuo muunnetaan
C:ksi turvallisesti}

Purkka käyttää tyyppipäättely toteuttamisen pohjana yleisesti käytettyä
Damas-Hindley-Milner -algoritmia~\citep{hindley, milner, damas}.

Jotta päättelyalgoritmi toimisi lineaariaikaisesti suhteessa syötteen kokoon,
osassa lausekkeista muuttujien tyyppien tulee olla tiedossa sillä hetkellä, kun
lausekkeen tyyppiä selvitetään. Yhteen- ja vähennyslasku voi vaatia myös
tyyppimäärittelyt, jos yhteenlaskettavat parametrit ovat osoittimia\footnote{C
sallii osoitinmuuttujan ja kokonaisluvun yhteen- ja vähennyslaskun sekä kahden
osoittimen vähennyslaskun.}. Näistä selkein esimerkki on struct-tyyppien kentän
käyttäminen, jonka tyyppiä kääntäjä ei suostu päättelemään, jos muuttujan
tyyppi ei ole tiedossa. Koodissa~\ref{fig:structinfer} on kaksi esimerkkiä
tyyppipäättelystä struct-muuttujiin: ensimmäisessä esimerkissä
tyyppipäättely onnistuu, mutta toisessa ei.

\begin{listing}[ht!]
    \inputminted{Rust}{koodi/infer.prk}
    \caption{Esimerkki tyyppipäättelystä.}
    \label{fig:structinfer}
\end{listing}

\FloatBarrier

\hl {Esimerkissä kysymysmerkkejä. Selitys auki}

\subsection{Makrot}

\hl{Liian lyhyt numeroiduksi aliluvuksi}

\hl{Todo: speksi makroista, tai ainakin lisää selitystä. Kääntäjässä ei ole
toistaiseksi mitään tehtynä Purkka-makrojen eteen.}

Koska Purkan tulee olla myös makrojen osalta C-yhteensopiva, Purkka osaa
laajentaa C-makroja. Purkka-kääntäjä pystyy muuntamaan makrokutsun
C-lähdekoodiksi, laajentamaan sen C-esikäsittelijällä ja muuntamaan makron
laajennettu muoto takaisin Purkka-koodiksi.

Purkassa on myös oma makrojärjestelmä, joka toimii hahmotunnistuksella ja
rekursiolla.\footnote{Referenssikääntäjään (ks. luku \ref{sec:results}) ei ole
toteutettu makroja.} Jos makrot eivät sisällä rekursiota tai hahmontunnistusta,
ne voidaan muuntaa C-makroiksi.

\hl{Teoriassa myös hahmontunnistuksen ja rekursion voisi muuntaa C-makroiksi,
käyttäen hyväksi C-makrojen nurkkatapauksia.}

\subsection{Suoritusaikaiset ominaisuudet ja laajennokset}

Purkka ei sisällä yhtään suoritusaikaista ominaisuutta, joita ei ole C:ssä.
Syntaksi kuitenkin sisältää \texttt{pragma}-avainsanan, jota voidaan käyttää
vastaavasti kuin C:n esikäsittelijän pragmaa erilaisten laajennosten
käyttämiseen. Esimerkiksi OpenMP-laajennosta käytetään pragmojen läpi.

Useat C-toteutukset sisältävät erilaisia laajennoksia, joiden tarkoituksena on
mahdollistaa eilaisten alustariippuvaisten ominaisuuksien käyttö. Benchmarks
gamessa yksi käytetyimmistä laajennoksista on SIMD-tyypit, joita varten
esimerkiksi GCC-kääntäjällä on oma syntaksinsa. GCC:llä SIMD-tyypit voidaan
määritellä käyttämällä \texttt{\_\_attribute\_\_((vector\_size))} -määrettä.
Purkka osaa käyttää useita GCC:n laajennoksia.

Sulkeumien toteutus olettaa, että C-kääntäjä tukee laajennoksena sulkeumia.
\hl{Tähän (tai muualle) lause lambdojen ja sulkeumien erosta?}

\subsection{Ohjelmointikielen kääntäminen}

Purkan kääntäminen C-koodiksi C-koodiksi on hieman normaalia kääntämistä
monimutkaisempaa. Koska Purkan tulee pystyä muuntamaan Purkka-koodia C-koodiksi
mutta myös C-koodia Purkka-koodiksi makrojen laajentamisen myötä, kääntäjän
pitää ymmärtää kahta ohjelmointikieltä yhden sijaan, sekä muuntamaan niitä
toisikseen. Kuvassa~\ref{fig:compilerarch} on kaavio Purkan kääntämisestä.

Suurimman osan purkan syntaksipuista saa käännettyä lähes identtisiksi C:n
syntaksipuiksi, mutta muutamat ominaisuudet vaativat enemmän työtä. Suurin
näistä on tyyppipäättely. Jotkut muut ominaisuudet vaativat myös
monimutkaisempia muutoksia, kuten \texttt{if}-lausekkeet sekä lambdalausekkeet.
Näistä \texttt{if}-lausekkeet käännetään käyttäen välimuuttujaa.
Lambdalausekkeet taas käännetään nostamalla lambda erilliseksi funktioksi ja
korvaamalla lambda osoittimella tähän funktioon.

\hl{2 viimeistä virkettä pois?}
