\section{Purkka-ohjelmointikieli}
\label{sec:purkka}

Tässä luvussa määritellään Purkka-ohjelmointikieli.

\subsection{Tyypit}

Jotta yhteensopivuus C:n kanssa olisi joustavaa, Purkan tyyppijärjestelmä
muodostetaan mahdollisimman paljon C:n kaltaiseksi. C:n tyyppisyntaksi sisältää
useita erilaisia tapoja ilmaista samaa pohjatyyppiä -- esimerkisi
\texttt{long}, \texttt{signed~long}, \texttt{long~int} ja
\texttt{signed~long~int} ilmaisevat kokonaislukutyyppiä, joka pystyy
sisältämään ainakin luvut $[-(2^{31} - 1), 2^{31}-1]$ \footnote{Käytännössä
modernit implementaatiot käyttävät kahden komplementtia kokonaislukujen
ilmaisemiseen, jolloin 32-bittinen kokonaislukumuuttuja voi sisältää luvut
$[-2^{31}, 2^{31}]$.}\citationneeded. Nämä tyypit ovat kuitenkin standardien
mukaisessa C:ssä keskenään täysin vaihdettavissa, eli kielen ei tarvitse pystyä
kääntymään jokaiseen mahdolliseen vaihtoehtoon. Perustyypit ovat hyvin lähellä
Rustin pohjatyyppejä\citationneeded. Purkka tarvitsee erikseen tyypit
\texttt{char}, \texttt{i8} ja \texttt{u8}, sillä C:n \texttt{char}-tyyppiä ei
ole määritelty tarkemmin joko kokonaisluvuksi tai 
\texttt{signed char} ja \texttt{unsigned char} ovat erillisiä tyyppejä.

Määritetään Purkkaan seuraavat alkeistyypit: \\[0.3cm]
\begin{tabular}{@{}p{5.8cm}p{8.7cm}@{}} \toprule
    Purkka-tyyppi & Purkka-tyyppiä vastaava C-tyyppi \\ \midrule
    \texttt{void} & \texttt{void} \\
    \texttt{char} & \texttt{char} \\
    \texttt{i8}, \texttt{i16}, \texttt{i32}, \texttt{i64} &
    \texttt{int8\_t}, \texttt{int16\_t}, \texttt{int32\_t}, \texttt{int64\_t} \\
    \texttt{u8}, \texttt{u16}, \texttt{u32}, \texttt{u64} &
    \texttt{uint8\_t}, \texttt{uint16\_t}, \texttt{uint32\_t}, \texttt{uint64\_t} \\
    \texttt{float} & \texttt{float} \\
    \texttt{double} & \texttt{double} \\
    [0.3cm]

    \texttt{cbyte}, \texttt{cshort}, \texttt{cint}, \texttt{clong}, \texttt{clonglong}
    & \texttt{signed char}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{long long} \\
    \noalign{\vspace{0.3cm}}%

    \texttt{cubyte}, \texttt{cushort}, \texttt{cuint}, \texttt{culong}, \texttt{culonglong}
    & \texttt{unsigned char}, \texttt{unsigned short}, \texttt{unsigned int},
      \texttt{unsigned long}, \texttt{unsigned long long} \\
    \bottomrule
\end{tabular} \\

Määritetään näiden alkeistyyppien pohjalta osoitintyypit, taulukkotyypit sekä
yhdistetyypit: \\[0.3cm]
\begin{tabular}{@{}ll@{}} \toprule
    Purkka-tyyppi & Purkka-tyyppiä vastaava C-tyyppi \\ \midrule
    \texttt{\&T, \&?T} & \texttt{T *} \\
    [0.2cm]

    \texttt{[T]} & \texttt{T\textsubscript{declaration specifiers}[]T\textsubscript{direct abstract declarator}} \\
    \texttt{[T;expr]} & \texttt{T\textsubscript{declaration specifiers}[expr]T\textsubscript{direct abstract declarator}} \\
    [0.2cm]

    \texttt{fun t: (T ..) -> R} & \texttt{R\textsubscript{declaration specifiers}~t(T ..)R\textsubscript{direct abstract declarator}} \\
    \texttt{fun (T ..) -> R} & \texttt{R\textsubscript{declaration specifiers}~(*)(T ..)R\textsubscript{direct abstract declarator}} \\
    [0.2cm]

    \texttt{struct \{ k: T ..\}} & \texttt{struct \{ T k ..\}} \\
    \texttt{enum \{ A [= expr] ..\}} & \texttt{enum \{ A [= expr] ..\}} \\
    \texttt{union \{ k: T ..\}} & \texttt{union \{ T k ..\}} \\
    [0.2cm]

    \texttt{(T1 ..)} & \texttt{struct \{ T1 e1; ..\}} \\
    \texttt{enum \{ T(T1 ..) .. \}} & \texttt{struct \{ union \{T1 t1 ..\} v; enum \{T ..\} e;\}} \\
    [0.2cm]

    GCC-laajennokset & \\
    \texttt{attribute(T, ...))} & \texttt{T \_\_attribute\_\_((...))} \\

    \bottomrule
\end{tabular} \\

Koska kieli ei voi erota C:stä suoritusaikaisesti, tyypitys on hyvin lähellä
C:n tyypitystä.

Tyypit:
 C + tagged union + non-nullable pointer

kuinka tagged union käännetään C:ksi? Entä non-nullable ptr?

tyyppi-inferenssi

Mitä optimointeja non-null tarjoaa? Entä tagged union?

\subsection{Tyyppi-inferenssi}



\subsection{Syntaksi}

Syntaksi:

funktiot on fun, koska se tekee ohjelmoinnista hauskempaa

deklaraatiot: tyyppi-inferenssi

tyyppisyntaksi "käänteinen" C:hen verrattuna
C:ssä suurin ongelma on declspec ennen nimeä, mutta directdecl nimen jäklkeem

static:
    funktiodeklaaratiossa/globaaleissa muuttujissa pub => ei static,
    muuttujissa static => static

expressiot:
    yksinkertaistettu kielioppi operaattorijumppaan
    Array literal != Struct literal
    if/ym. ekspressioita
        - miten muunnos?

statementit:
    suurin osa expr

\subsection{Makrot}

Koska Purkan tulee olla myös makrojen osalta C-yhteensopiva, Purkka osaa
laajentaa C-makroja. Purkka-kääntäjä pystyy muuntamaan makrokutsun
C-lähdekoodiksi, laajentamaan sen C-esikäsittelijällä ja muuntamaan makron
laajennettu muoto takaisin Purkka-koodiksi.

Purkassa on myös oma makrojärjestelmä, joka toimii hahmotunnistuksella ja
rekursiolla.\footnote{Referenssikääntäjään (ks. luku \ref{sec:results}) ei ole
toteutettu makroja.} Jos makrot eivät sisällä rekursiota tai hahmontunnistusta,
ne voidaan muuntaa C-makroiksi.

\hl{Teoriassa myös hahmontunnistuksen ja rekursion voisi muuntaa C-makroiksi,
käyttäen hyväksi C-makrojen detaileja.}

\subsection{Suoritusaikaiset ominaisuudet ja laajennokset}

Purkka ei sisällä yhtään suoritusaikaista ominaisuutta, joita ei ole C:ssä.
Syntaksi kuitenkin sisältää \texttt{pragma}-avainsanan, jota voidaan käyttää
vastaavasti kuin C:n esikäsittelijän pragmaa erilaisten laajennosten
käyttämiseen. Esimerkiksi OpenMP-laajennosta käytetään pragmojen läpi.

Useat C-toteutukset sisältävät erilaisia laajennoksia, joiden tarkoituksena on
mahdollistaa eilaisten alustariippuvaisten ominaisuuksien käyttö. Benchmarks
gamessa yksi käytetyimmistä laajennoksista on SIMD-tyypit, joita varten
esimerkiksi GCC-kääntäjällä on oma syntaksinsa. GCC:llä SIMD-tyypit voidaan
määritellä käyttäen \texttt{\_\_attribute\_\_(())} -\hl{määrettä}.
Purkka-kääntäjä osaa tunnistaa useita GCC:n laajennoksia ja välittää ne
eteenpäin.

Sulkeumien toteutus olettaa, että C-kääntäjä tukee laajennoksena sulkeumia.

\subsection{Ohjelmointikielen kääntäminen}

Purkan kääntäminen C-koodiksi on hieman normaalia kääntämistä monimutkaisempaa.
Koska Purkan tulee pystyä muuntamaan Purkka-koodia C-koodiksi, mutta myös
C-koodia purkka-koodiksi makrojen laajentamisen myötä, kääntäjän pitää ymmärtää
kahta ohjelmointikieltä yhden sijaan.

Suurin osa ominaisuuksista kääntyy suoraan vastaaviksi C-ominaisuuksiksi.
Muutamat vaatii työtä, kuten inferenssi, block expr, lambdat. Inferenssialgo
johonkin nurkkaan.

Lambdat käännetään siten, että funktion body nostetaan ulos lambdan paikalta,
ja korvataan funktio-osoittimella.

\hl{Koska kieli ymmärtää C:tä ja Purkkaa, ja muuntaa näiden välillä,
käännösprosessi on monimutkainen. Kuvassa} \ref{fig:compilerarch} \hl{näytetään
mahdollisimman epäselkeästi arkkitehtuuri.}

\begin{figure}[ht!]
        \footnotesize
        \begin{adjustbox}{center}
        \begin{tikzpicture}[-{Latex[length=2mm,width=3mm]},auto, main node/.style={draw,fill=white},align=center]
            \tikzstyle{ann} = [rounded corners,fill=black!4,draw=black]
            \tikzset{
                -|/.style={to path={-| (\tikztotarget)}},
                |-/.style={to path={|- (\tikztotarget)}},
            }

            \node[main node,text width=3cm,fill=black!10] (core) {Tiedosto syötetään kääntäjälle};

            \node[main node,text width=3.3cm] (purkkaparser) [right = of core] {Purkka-jäsentäjä};

            \node[main node] (cpurkka) [right = of purkkaparser,text width=3.5cm] {Muuntaja C-syntaksipuusta Purkka-syntaksipuuksi};
            \node[main node] (coremacro) [above = of cpurkka,text width=3.5cm] {Muuntaja Purkka-lausekkeista C-syntaksipuiksi};
            \node[main node,text width=3.5cm] (purkkac) [below = of cpurkka] {Muuntaja Purkka-syntaksipuusta C-syntaksipuuksi};
            \coordinate[above left = of coremacro] (phantom);

            \node[draw = none] (phantom1) [above = of coremacro, text width=3.5cm] {};
            \node[draw = none] (phantom3) [left = of phantom1, text width=3.3cm] {};
            \node[draw = none] (phantom2) [right = of phantom1, text width=2.3cm] {};

            \node[main node] (preprocessor) [right = of coremacro,text width=2.3cm] {C-esikäsittelijä};
            \node[main node] (cparser) [right = of cpurkka,text width=2.3cm] {C-jäsentäjä};

            \node[main node,text width=3.3cm] (cformat) [left = of purkkac] {C-syntaksipuun muuntaminen lähdekoodiksi};
            \node[main node,fill=black!10] (done) [left = of cformat] {Tiedosto on käännetty};

            \coordinate (phantom4) at ($(purkkaparser)!0.5!(purkkac)$);

            \draw (purkkaparser.170) |- (phantom) node[blur shadow={shadow blur steps=5},ann,above right = 0.2cm and 0cm]  {Purkka-koodi sisällyttää C-tiedoston} -| (preprocessor); 
            \draw (purkkaparser.130) |- node[blur shadow={shadow blur steps=5},ann,text width=2.7cm,above right = 0.2cm and -0.4cm] {Purkka-koodi kutsuu C-makroa} (coremacro);
            \draw (purkkaparser) |- (phantom4) -| (purkkac);

            \path[every node/.style={font=\sffamily\small},-{Latex[length=2mm,width=3mm]}]
            (core) edge (purkkaparser)
            (coremacro) edge (preprocessor)
            (preprocessor) edge (cparser)
            (cparser) edge (cpurkka)
            (cpurkka) edge (purkkaparser)
            (purkkac) edge (cformat)
            (cformat) edge (done)
            ;

            \draw node[above = of phantom1] {\textbf{AST-muuntaja}};
            \draw node[above = of phantom2] {\textbf{C-kääntäjä}};
            \draw node[above = of phantom3] {\textbf{Purkka-kääntäjä}};
            \begin{scope}[on background layer]
                \draw[thick,dotted,fill=black!5] ($(phantom1.north west)+(-0.3,2)$)  rectangle ($(purkkac.south east)+(0.3,-0.4)$);
                \draw[thick,dotted,fill=black!5] ($(phantom2.north west)+(-0.3,2)$)  rectangle ($(cparser.south east)+(0.3,-0.4)$);
                \draw[thick,dotted,fill=black!5] ($(phantom3.north west)+(-0.3,2)$)  rectangle ($(purkkaparser.south east)+(0.3,-0.4)$);
            \end{scope}
        \end{tikzpicture}
        \end{adjustbox}

        \caption{Graafi kääntämisprosessin hienouksista}
        \label{fig:compilerarch}
\end{figure}
